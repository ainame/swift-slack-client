#if WebAPI_Apps
// Generated by swift-openapi-generator, do not modify.
@_spi(Generated) import OpenAPIRuntime
#if os(Linux)
@preconcurrency import struct Foundation.Data
@preconcurrency import struct Foundation.Date
@preconcurrency import struct Foundation.URL
#else
import struct Foundation.Data
import struct Foundation.Date
import struct Foundation.URL
#endif
import HTTPTypes

extension Client {
    /// Generate a temporary Socket Mode WebSocket URL that your app can connect to in order to receive events and interactive payloads
    /// over.
    ///
    /// - Remark: HTTP `POST /apps.connections.open`.
    /// - Remark: Generated from `#/paths//apps.connections.open/post(appsConnectionsOpen)`.
    func appsConnectionsOpen(_ input: Operations.AppsConnectionsOpen.Input) async throws -> Operations.AppsConnectionsOpen.Output {
        try await client.send(
            input: input,
            forOperation: Operations.AppsConnectionsOpen.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/apps.connections.open",
                    parameters: [],
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post,
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept,
                )
                let body: OpenAPIRuntime.HTTPBody? = switch input.body {
                case .none:
                    nil
                case let .json(value):
                    try converter.setOptionalRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8",
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.AppsConnectionsOpen.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                        ],
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AppsConnectionsOpenResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            },
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody,
                        ),
                    )
                }
            },
        )
    }

    /// Get a list of authorizations for the given event context. Each authorization represents an app installation that the event is
    /// visible to.
    ///
    /// - Remark: HTTP `POST /apps.event.authorizations.list`.
    /// - Remark: Generated from `#/paths//apps.event.authorizations.list/post(appsEventAuthorizationsList)`.
    func appsEventAuthorizationsList(_ input: Operations.AppsEventAuthorizationsList.Input) async throws -> Operations
        .AppsEventAuthorizationsList.Output {
        try await client.send(
            input: input,
            forOperation: Operations.AppsEventAuthorizationsList.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/apps.event.authorizations.list",
                    parameters: [],
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post,
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept,
                )
                let body: OpenAPIRuntime.HTTPBody? = switch input.body {
                case let .json(value):
                    try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8",
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.AppsEventAuthorizationsList.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                        ],
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AppsEventAuthorizationsListResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            },
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody,
                        ),
                    )
                }
            },
        )
    }

    /// Create an app from an app manifest.
    ///
    /// - Remark: HTTP `POST /apps.manifest.create`.
    /// - Remark: Generated from `#/paths//apps.manifest.create/post(appsManifestCreate)`.
    func appsManifestCreate(_ input: Operations.AppsManifestCreate.Input) async throws -> Operations.AppsManifestCreate.Output {
        try await client.send(
            input: input,
            forOperation: Operations.AppsManifestCreate.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/apps.manifest.create",
                    parameters: [],
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post,
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept,
                )
                let body: OpenAPIRuntime.HTTPBody? = switch input.body {
                case let .json(value):
                    try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8",
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.AppsManifestCreate.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                        ],
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AppsManifestCreateResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            },
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody,
                        ),
                    )
                }
            },
        )
    }

    /// Permanently deletes an app created through app manifests
    ///
    /// - Remark: HTTP `POST /apps.manifest.delete`.
    /// - Remark: Generated from `#/paths//apps.manifest.delete/post(appsManifestDelete)`.
    func appsManifestDelete(_ input: Operations.AppsManifestDelete.Input) async throws -> Operations.AppsManifestDelete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.AppsManifestDelete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/apps.manifest.delete",
                    parameters: [],
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post,
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept,
                )
                let body: OpenAPIRuntime.HTTPBody? = switch input.body {
                case let .json(value):
                    try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8",
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.AppsManifestDelete.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                        ],
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AppsManifestDeleteResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            },
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody,
                        ),
                    )
                }
            },
        )
    }

    /// Export an app manifest from an existing app
    ///
    /// - Remark: HTTP `POST /apps.manifest.export`.
    /// - Remark: Generated from `#/paths//apps.manifest.export/post(appsManifestExport)`.
    func appsManifestExport(_ input: Operations.AppsManifestExport.Input) async throws -> Operations.AppsManifestExport.Output {
        try await client.send(
            input: input,
            forOperation: Operations.AppsManifestExport.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/apps.manifest.export",
                    parameters: [],
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post,
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept,
                )
                let body: OpenAPIRuntime.HTTPBody? = switch input.body {
                case let .json(value):
                    try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8",
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.AppsManifestExport.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                        ],
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AppsManifestExportResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            },
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody,
                        ),
                    )
                }
            },
        )
    }

    /// Update an app from an app manifest
    ///
    /// - Remark: HTTP `POST /apps.manifest.update`.
    /// - Remark: Generated from `#/paths//apps.manifest.update/post(appsManifestUpdate)`.
    func appsManifestUpdate(_ input: Operations.AppsManifestUpdate.Input) async throws -> Operations.AppsManifestUpdate.Output {
        try await client.send(
            input: input,
            forOperation: Operations.AppsManifestUpdate.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/apps.manifest.update",
                    parameters: [],
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post,
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept,
                )
                let body: OpenAPIRuntime.HTTPBody? = switch input.body {
                case let .json(value):
                    try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8",
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.AppsManifestUpdate.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                        ],
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AppsManifestUpdateResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            },
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody,
                        ),
                    )
                }
            },
        )
    }

    /// Validate an app manifest
    ///
    /// - Remark: HTTP `POST /apps.manifest.validate`.
    /// - Remark: Generated from `#/paths//apps.manifest.validate/post(appsManifestValidate)`.
    func appsManifestValidate(_ input: Operations.AppsManifestValidate.Input) async throws -> Operations.AppsManifestValidate.Output {
        try await client.send(
            input: input,
            forOperation: Operations.AppsManifestValidate.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/apps.manifest.validate",
                    parameters: [],
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post,
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept,
                )
                let body: OpenAPIRuntime.HTTPBody? = switch input.body {
                case let .json(value):
                    try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8",
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.AppsManifestValidate.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                        ],
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AppsManifestValidateResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            },
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody,
                        ),
                    )
                }
            },
        )
    }

    /// Uninstalls your app from a workspace.
    ///
    /// - Remark: HTTP `POST /apps.uninstall`.
    /// - Remark: Generated from `#/paths//apps.uninstall/post(appsUninstall)`.
    func appsUninstall(_ input: Operations.AppsUninstall.Input) async throws -> Operations.AppsUninstall.Output {
        try await client.send(
            input: input,
            forOperation: Operations.AppsUninstall.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/apps.uninstall",
                    parameters: [],
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post,
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept,
                )
                let body: OpenAPIRuntime.HTTPBody? = switch input.body {
                case let .json(value):
                    try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8",
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.AppsUninstall.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                        ],
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AppsUninstallResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            },
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody,
                        ),
                    )
                }
            },
        )
    }
}
#endif
