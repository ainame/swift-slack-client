#if WebAPI_Canvases
// Generated by swift-openapi-generator, do not modify.
@_spi(Generated) import OpenAPIRuntime
#if os(Linux)
@preconcurrency import struct Foundation.Data
@preconcurrency import struct Foundation.Date
@preconcurrency import struct Foundation.URL
#else
import struct Foundation.Data
import struct Foundation.Date
import struct Foundation.URL
#endif
import HTTPTypes

extension Client {
    /// Remove access to a canvas for specified entities
    ///
    /// - Remark: HTTP `POST /canvases.access.delete`.
    /// - Remark: Generated from `#/paths//canvases.access.delete/post(canvasesAccessDelete)`.
    func canvasesAccessDelete(_ input: Operations.CanvasesAccessDelete.Input) async throws -> Operations.CanvasesAccessDelete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CanvasesAccessDelete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/canvases.access.delete",
                    parameters: [],
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post,
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept,
                )
                let body: OpenAPIRuntime.HTTPBody? = switch input.body {
                case let .json(value):
                    try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8",
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.CanvasesAccessDelete.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                        ],
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.CanvasesAccessDeleteResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            },
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody,
                        ),
                    )
                }
            },
        )
    }

    /// Sets the access level to a canvas for specified entities
    ///
    /// - Remark: HTTP `POST /canvases.access.set`.
    /// - Remark: Generated from `#/paths//canvases.access.set/post(canvasesAccessSet)`.
    func canvasesAccessSet(_ input: Operations.CanvasesAccessSet.Input) async throws -> Operations.CanvasesAccessSet.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CanvasesAccessSet.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/canvases.access.set",
                    parameters: [],
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post,
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept,
                )
                let body: OpenAPIRuntime.HTTPBody? = switch input.body {
                case let .json(value):
                    try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8",
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.CanvasesAccessSet.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                        ],
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.CanvasesAccessSetResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            },
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody,
                        ),
                    )
                }
            },
        )
    }

    /// Create canvas for a user
    ///
    /// - Remark: HTTP `POST /canvases.create`.
    /// - Remark: Generated from `#/paths//canvases.create/post(canvasesCreate)`.
    func canvasesCreate(_ input: Operations.CanvasesCreate.Input) async throws -> Operations.CanvasesCreate.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CanvasesCreate.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/canvases.create",
                    parameters: [],
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post,
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept,
                )
                let body: OpenAPIRuntime.HTTPBody? = switch input.body {
                case let .json(value):
                    try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8",
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.CanvasesCreate.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                        ],
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.CanvasesCreateResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            },
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody,
                        ),
                    )
                }
            },
        )
    }

    /// Deletes a canvas
    ///
    /// - Remark: HTTP `POST /canvases.delete`.
    /// - Remark: Generated from `#/paths//canvases.delete/post(canvasesDelete)`.
    func canvasesDelete(_ input: Operations.CanvasesDelete.Input) async throws -> Operations.CanvasesDelete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CanvasesDelete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/canvases.delete",
                    parameters: [],
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post,
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept,
                )
                let body: OpenAPIRuntime.HTTPBody? = switch input.body {
                case let .json(value):
                    try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8",
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.CanvasesDelete.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                        ],
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.CanvasesDeleteResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            },
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody,
                        ),
                    )
                }
            },
        )
    }

    /// Update an existing canvas
    ///
    /// - Remark: HTTP `POST /canvases.edit`.
    /// - Remark: Generated from `#/paths//canvases.edit/post(canvasesEdit)`.
    func canvasesEdit(_ input: Operations.CanvasesEdit.Input) async throws -> Operations.CanvasesEdit.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CanvasesEdit.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/canvases.edit",
                    parameters: [],
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post,
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept,
                )
                let body: OpenAPIRuntime.HTTPBody? = switch input.body {
                case let .json(value):
                    try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8",
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.CanvasesEdit.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                        ],
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.CanvasesEditResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            },
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody,
                        ),
                    )
                }
            },
        )
    }

    /// Find sections matching the provided criteria
    ///
    /// - Remark: HTTP `POST /canvases.sections.lookup`.
    /// - Remark: Generated from `#/paths//canvases.sections.lookup/post(canvasesSectionsLookup)`.
    func canvasesSectionsLookup(_ input: Operations.CanvasesSectionsLookup.Input) async throws -> Operations.CanvasesSectionsLookup.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CanvasesSectionsLookup.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/canvases.sections.lookup",
                    parameters: [],
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post,
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept,
                )
                let body: OpenAPIRuntime.HTTPBody? = switch input.body {
                case let .json(value):
                    try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8",
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.CanvasesSectionsLookup.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                        ],
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.CanvasesSectionsLookupResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            },
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody,
                        ),
                    )
                }
            },
        )
    }
}
#endif
