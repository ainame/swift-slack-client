// Generated by swift-openapi-generator, do not modify.
@_spi(Generated) import OpenAPIRuntime
#if os(Linux)
@preconcurrency import struct Foundation.URL
@preconcurrency import struct Foundation.Data
@preconcurrency import struct Foundation.Date
#else
import struct Foundation.URL
import struct Foundation.Data
import struct Foundation.Date
#endif
/// API operations, with input and output types, generated from `#/paths` in the OpenAPI document.

#if WebAPI_Chat
extension Operations {
public enum ChatDelete {
    public static let id: Swift.String = "chatDelete"
    public struct Input: Sendable, Hashable {
        /// - Remark: Generated from `#/paths/chat.delete/POST/header`.
        public struct Headers: Sendable, Hashable {
            public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ChatDelete.AcceptableContentType>]
            /// Creates a new `Headers`.
            ///
            /// - Parameters:
            ///   - accept:
            public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ChatDelete.AcceptableContentType>] = .defaultValues()) {
                self.accept = accept
            }
        }
        public var headers: Operations.ChatDelete.Input.Headers
        /// - Remark: Generated from `#/paths/chat.delete/POST/requestBody`.
        @frozen public enum Body: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/chat.delete/POST/requestBody/json`.
            public struct JsonPayload: Codable, Hashable, Sendable {
                /// Channel containing the message to be deleted.
                ///
                /// - Remark: Generated from `#/paths/chat.delete/POST/requestBody/json/channel`.
                public var channel: Swift.String
                /// Timestamp of the message to be deleted.
                ///
                /// - Remark: Generated from `#/paths/chat.delete/POST/requestBody/json/ts`.
                public var ts: Swift.String
                /// Pass true to delete the message as the authed user with chat:write:user scope. Bot users in this context are considered authed users. If unused or false, the message will be deleted with chat:write:bot scope.
                ///
                /// - Remark: Generated from `#/paths/chat.delete/POST/requestBody/json/asUser`.
                public var asUser: Swift.Bool?
                /// Creates a new `JsonPayload`.
                ///
                /// - Parameters:
                ///   - channel: Channel containing the message to be deleted.
                ///   - ts: Timestamp of the message to be deleted.
                ///   - asUser: Pass true to delete the message as the authed user with chat:write:user scope. Bot users in this context are considered authed users. If unused or false, the message will be deleted with chat:write:bot scope.
                public init(
                    channel: Swift.String,
                    ts: Swift.String,
                    asUser: Swift.Bool? = nil
                ) {
                    self.channel = channel
                    self.ts = ts
                    self.asUser = asUser
                }
                public enum CodingKeys: String, CodingKey {
                    case channel
                    case ts
                    case asUser
                }
            }
            /// - Remark: Generated from `#/paths/chat.delete/POST/requestBody/content/application\/json`.
            case json(Operations.ChatDelete.Input.Body.JsonPayload)
        }
        public var body: Operations.ChatDelete.Input.Body
        /// Creates a new `Input`.
        ///
        /// - Parameters:
        ///   - headers:
        ///   - body:
        public init(
            headers: Operations.ChatDelete.Input.Headers = .init(),
            body: Operations.ChatDelete.Input.Body
        ) {
            self.headers = headers
            self.body = body
        }
    }
    @frozen public enum Output: Sendable, Hashable {
        public struct Ok: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/chat.delete/POST/responses/200/content`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/chat.delete/POST/responses/200/content/application\/json`.
                case json(Components.Schemas.ChatDeleteResponse)
                /// The associated value of the enum case if `self` is `.json`.
                ///
                /// - Throws: An error if `self` is not `.json`.
                /// - SeeAlso: `.json`.
                public var json: Components.Schemas.ChatDeleteResponse {
                    get throws {
                        switch self {
                        case let .json(body):
                            return body
                        }
                    }
                }
            }
            /// Received HTTP response body
            public var body: Operations.ChatDelete.Output.Ok.Body
            /// Creates a new `Ok`.
            ///
            /// - Parameters:
            ///   - body: Received HTTP response body
            public init(body: Operations.ChatDelete.Output.Ok.Body) {
                self.body = body
            }
        }
        /// OK
        ///
        /// - Remark: Generated from `#/paths//chat.delete/post(chatDelete)/responses/200`.
        ///
        /// HTTP response code: `200 ok`.
        case ok(Operations.ChatDelete.Output.Ok)
        /// The associated value of the enum case if `self` is `.ok`.
        ///
        /// - Throws: An error if `self` is not `.ok`.
        /// - SeeAlso: `.ok`.
        public var ok: Operations.ChatDelete.Output.Ok {
            get throws {
                switch self {
                case let .ok(response):
                    return response
                default:
                    try throwUnexpectedResponseStatus(
                        expectedStatus: "ok",
                        response: self
                    )
                }
            }
        }
        /// Undocumented response.
        ///
        /// A response with a code that is not documented in the OpenAPI document.
        case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
    }
    @frozen public enum AcceptableContentType: AcceptableProtocol {
        case json
        case other(Swift.String)
        public init?(rawValue: Swift.String) {
            switch rawValue.lowercased() {
            case "application/json":
                self = .json
            default:
                self = .other(rawValue)
            }
        }
        public var rawValue: Swift.String {
            switch self {
            case let .other(string):
                return string
            case .json:
                return "application/json"
            }
        }
        public static var allCases: [Self] {
            [
                .json
            ]
        }
    }
}
public enum ChatDeleteScheduledMessage {
    public static let id: Swift.String = "chatDeleteScheduledMessage"
    public struct Input: Sendable, Hashable {
        /// - Remark: Generated from `#/paths/chat.deleteScheduledMessage/POST/header`.
        public struct Headers: Sendable, Hashable {
            public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ChatDeleteScheduledMessage.AcceptableContentType>]
            /// Creates a new `Headers`.
            ///
            /// - Parameters:
            ///   - accept:
            public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ChatDeleteScheduledMessage.AcceptableContentType>] = .defaultValues()) {
                self.accept = accept
            }
        }
        public var headers: Operations.ChatDeleteScheduledMessage.Input.Headers
        /// - Remark: Generated from `#/paths/chat.deleteScheduledMessage/POST/requestBody`.
        @frozen public enum Body: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/chat.deleteScheduledMessage/POST/requestBody/json`.
            public struct JsonPayload: Codable, Hashable, Sendable {
                /// The channel the scheduled_message is posting to.
                ///
                /// - Remark: Generated from `#/paths/chat.deleteScheduledMessage/POST/requestBody/json/channel`.
                public var channel: Swift.String
                /// scheduled_message_id returned from call to chat.scheduleMessage.
                ///
                /// - Remark: Generated from `#/paths/chat.deleteScheduledMessage/POST/requestBody/json/scheduledMessageId`.
                public var scheduledMessageId: Swift.String
                /// Pass true to delete the message as the authed user with chat:write:user scope. Bot users in this context are considered authed users. If unused or false, the message will be deleted with chat:write:bot scope.
                ///
                /// - Remark: Generated from `#/paths/chat.deleteScheduledMessage/POST/requestBody/json/asUser`.
                public var asUser: Swift.Bool?
                /// Creates a new `JsonPayload`.
                ///
                /// - Parameters:
                ///   - channel: The channel the scheduled_message is posting to.
                ///   - scheduledMessageId: scheduled_message_id returned from call to chat.scheduleMessage.
                ///   - asUser: Pass true to delete the message as the authed user with chat:write:user scope. Bot users in this context are considered authed users. If unused or false, the message will be deleted with chat:write:bot scope.
                public init(
                    channel: Swift.String,
                    scheduledMessageId: Swift.String,
                    asUser: Swift.Bool? = nil
                ) {
                    self.channel = channel
                    self.scheduledMessageId = scheduledMessageId
                    self.asUser = asUser
                }
                public enum CodingKeys: String, CodingKey {
                    case channel
                    case scheduledMessageId
                    case asUser
                }
            }
            /// - Remark: Generated from `#/paths/chat.deleteScheduledMessage/POST/requestBody/content/application\/json`.
            case json(Operations.ChatDeleteScheduledMessage.Input.Body.JsonPayload)
        }
        public var body: Operations.ChatDeleteScheduledMessage.Input.Body
        /// Creates a new `Input`.
        ///
        /// - Parameters:
        ///   - headers:
        ///   - body:
        public init(
            headers: Operations.ChatDeleteScheduledMessage.Input.Headers = .init(),
            body: Operations.ChatDeleteScheduledMessage.Input.Body
        ) {
            self.headers = headers
            self.body = body
        }
    }
    @frozen public enum Output: Sendable, Hashable {
        public struct Ok: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/chat.deleteScheduledMessage/POST/responses/200/content`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/chat.deleteScheduledMessage/POST/responses/200/content/application\/json`.
                case json(Components.Schemas.ChatDeleteScheduledMessageResponse)
                /// The associated value of the enum case if `self` is `.json`.
                ///
                /// - Throws: An error if `self` is not `.json`.
                /// - SeeAlso: `.json`.
                public var json: Components.Schemas.ChatDeleteScheduledMessageResponse {
                    get throws {
                        switch self {
                        case let .json(body):
                            return body
                        }
                    }
                }
            }
            /// Received HTTP response body
            public var body: Operations.ChatDeleteScheduledMessage.Output.Ok.Body
            /// Creates a new `Ok`.
            ///
            /// - Parameters:
            ///   - body: Received HTTP response body
            public init(body: Operations.ChatDeleteScheduledMessage.Output.Ok.Body) {
                self.body = body
            }
        }
        /// OK
        ///
        /// - Remark: Generated from `#/paths//chat.deleteScheduledMessage/post(chatDeleteScheduledMessage)/responses/200`.
        ///
        /// HTTP response code: `200 ok`.
        case ok(Operations.ChatDeleteScheduledMessage.Output.Ok)
        /// The associated value of the enum case if `self` is `.ok`.
        ///
        /// - Throws: An error if `self` is not `.ok`.
        /// - SeeAlso: `.ok`.
        public var ok: Operations.ChatDeleteScheduledMessage.Output.Ok {
            get throws {
                switch self {
                case let .ok(response):
                    return response
                default:
                    try throwUnexpectedResponseStatus(
                        expectedStatus: "ok",
                        response: self
                    )
                }
            }
        }
        /// Undocumented response.
        ///
        /// A response with a code that is not documented in the OpenAPI document.
        case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
    }
    @frozen public enum AcceptableContentType: AcceptableProtocol {
        case json
        case other(Swift.String)
        public init?(rawValue: Swift.String) {
            switch rawValue.lowercased() {
            case "application/json":
                self = .json
            default:
                self = .other(rawValue)
            }
        }
        public var rawValue: Swift.String {
            switch self {
            case let .other(string):
                return string
            case .json:
                return "application/json"
            }
        }
        public static var allCases: [Self] {
            [
                .json
            ]
        }
    }
}
public enum ChatGetPermalink {
    public static let id: Swift.String = "chatGetPermalink"
    public struct Input: Sendable, Hashable {
        /// - Remark: Generated from `#/paths/chat.getPermalink/POST/header`.
        public struct Headers: Sendable, Hashable {
            public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ChatGetPermalink.AcceptableContentType>]
            /// Creates a new `Headers`.
            ///
            /// - Parameters:
            ///   - accept:
            public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ChatGetPermalink.AcceptableContentType>] = .defaultValues()) {
                self.accept = accept
            }
        }
        public var headers: Operations.ChatGetPermalink.Input.Headers
        /// - Remark: Generated from `#/paths/chat.getPermalink/POST/requestBody`.
        @frozen public enum Body: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/chat.getPermalink/POST/requestBody/json`.
            public struct JsonPayload: Codable, Hashable, Sendable {
                /// The ID of the conversation or channel containing the message.
                ///
                /// - Remark: Generated from `#/paths/chat.getPermalink/POST/requestBody/json/channel`.
                public var channel: Swift.String
                /// A message's ts value, uniquely identifying it within a channel.
                ///
                /// - Remark: Generated from `#/paths/chat.getPermalink/POST/requestBody/json/messageTs`.
                public var messageTs: Swift.String
                /// Creates a new `JsonPayload`.
                ///
                /// - Parameters:
                ///   - channel: The ID of the conversation or channel containing the message.
                ///   - messageTs: A message's ts value, uniquely identifying it within a channel.
                public init(
                    channel: Swift.String,
                    messageTs: Swift.String
                ) {
                    self.channel = channel
                    self.messageTs = messageTs
                }
                public enum CodingKeys: String, CodingKey {
                    case channel
                    case messageTs
                }
            }
            /// - Remark: Generated from `#/paths/chat.getPermalink/POST/requestBody/content/application\/json`.
            case json(Operations.ChatGetPermalink.Input.Body.JsonPayload)
        }
        public var body: Operations.ChatGetPermalink.Input.Body
        /// Creates a new `Input`.
        ///
        /// - Parameters:
        ///   - headers:
        ///   - body:
        public init(
            headers: Operations.ChatGetPermalink.Input.Headers = .init(),
            body: Operations.ChatGetPermalink.Input.Body
        ) {
            self.headers = headers
            self.body = body
        }
    }
    @frozen public enum Output: Sendable, Hashable {
        public struct Ok: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/chat.getPermalink/POST/responses/200/content`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/chat.getPermalink/POST/responses/200/content/application\/json`.
                case json(Components.Schemas.ChatGetPermalinkResponse)
                /// The associated value of the enum case if `self` is `.json`.
                ///
                /// - Throws: An error if `self` is not `.json`.
                /// - SeeAlso: `.json`.
                public var json: Components.Schemas.ChatGetPermalinkResponse {
                    get throws {
                        switch self {
                        case let .json(body):
                            return body
                        }
                    }
                }
            }
            /// Received HTTP response body
            public var body: Operations.ChatGetPermalink.Output.Ok.Body
            /// Creates a new `Ok`.
            ///
            /// - Parameters:
            ///   - body: Received HTTP response body
            public init(body: Operations.ChatGetPermalink.Output.Ok.Body) {
                self.body = body
            }
        }
        /// OK
        ///
        /// - Remark: Generated from `#/paths//chat.getPermalink/post(chatGetPermalink)/responses/200`.
        ///
        /// HTTP response code: `200 ok`.
        case ok(Operations.ChatGetPermalink.Output.Ok)
        /// The associated value of the enum case if `self` is `.ok`.
        ///
        /// - Throws: An error if `self` is not `.ok`.
        /// - SeeAlso: `.ok`.
        public var ok: Operations.ChatGetPermalink.Output.Ok {
            get throws {
                switch self {
                case let .ok(response):
                    return response
                default:
                    try throwUnexpectedResponseStatus(
                        expectedStatus: "ok",
                        response: self
                    )
                }
            }
        }
        /// Undocumented response.
        ///
        /// A response with a code that is not documented in the OpenAPI document.
        case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
    }
    @frozen public enum AcceptableContentType: AcceptableProtocol {
        case json
        case other(Swift.String)
        public init?(rawValue: Swift.String) {
            switch rawValue.lowercased() {
            case "application/json":
                self = .json
            default:
                self = .other(rawValue)
            }
        }
        public var rawValue: Swift.String {
            switch self {
            case let .other(string):
                return string
            case .json:
                return "application/json"
            }
        }
        public static var allCases: [Self] {
            [
                .json
            ]
        }
    }
}
public enum ChatMeMessage {
    public static let id: Swift.String = "chatMeMessage"
    public struct Input: Sendable, Hashable {
        /// - Remark: Generated from `#/paths/chat.meMessage/POST/header`.
        public struct Headers: Sendable, Hashable {
            public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ChatMeMessage.AcceptableContentType>]
            /// Creates a new `Headers`.
            ///
            /// - Parameters:
            ///   - accept:
            public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ChatMeMessage.AcceptableContentType>] = .defaultValues()) {
                self.accept = accept
            }
        }
        public var headers: Operations.ChatMeMessage.Input.Headers
        /// - Remark: Generated from `#/paths/chat.meMessage/POST/requestBody`.
        @frozen public enum Body: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/chat.meMessage/POST/requestBody/json`.
            public struct JsonPayload: Codable, Hashable, Sendable {
                /// Channel to send message to. Can be a public channel, private group or IM channel. Can be an encoded ID, or a name.
                ///
                /// - Remark: Generated from `#/paths/chat.meMessage/POST/requestBody/json/channel`.
                public var channel: Swift.String
                /// Text of the message to send.
                ///
                /// - Remark: Generated from `#/paths/chat.meMessage/POST/requestBody/json/text`.
                public var text: Swift.String
                /// Creates a new `JsonPayload`.
                ///
                /// - Parameters:
                ///   - channel: Channel to send message to. Can be a public channel, private group or IM channel. Can be an encoded ID, or a name.
                ///   - text: Text of the message to send.
                public init(
                    channel: Swift.String,
                    text: Swift.String
                ) {
                    self.channel = channel
                    self.text = text
                }
                public enum CodingKeys: String, CodingKey {
                    case channel
                    case text
                }
            }
            /// - Remark: Generated from `#/paths/chat.meMessage/POST/requestBody/content/application\/json`.
            case json(Operations.ChatMeMessage.Input.Body.JsonPayload)
        }
        public var body: Operations.ChatMeMessage.Input.Body
        /// Creates a new `Input`.
        ///
        /// - Parameters:
        ///   - headers:
        ///   - body:
        public init(
            headers: Operations.ChatMeMessage.Input.Headers = .init(),
            body: Operations.ChatMeMessage.Input.Body
        ) {
            self.headers = headers
            self.body = body
        }
    }
    @frozen public enum Output: Sendable, Hashable {
        public struct Ok: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/chat.meMessage/POST/responses/200/content`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/chat.meMessage/POST/responses/200/content/application\/json`.
                case json(Components.Schemas.ChatMeMessageResponse)
                /// The associated value of the enum case if `self` is `.json`.
                ///
                /// - Throws: An error if `self` is not `.json`.
                /// - SeeAlso: `.json`.
                public var json: Components.Schemas.ChatMeMessageResponse {
                    get throws {
                        switch self {
                        case let .json(body):
                            return body
                        }
                    }
                }
            }
            /// Received HTTP response body
            public var body: Operations.ChatMeMessage.Output.Ok.Body
            /// Creates a new `Ok`.
            ///
            /// - Parameters:
            ///   - body: Received HTTP response body
            public init(body: Operations.ChatMeMessage.Output.Ok.Body) {
                self.body = body
            }
        }
        /// OK
        ///
        /// - Remark: Generated from `#/paths//chat.meMessage/post(chatMeMessage)/responses/200`.
        ///
        /// HTTP response code: `200 ok`.
        case ok(Operations.ChatMeMessage.Output.Ok)
        /// The associated value of the enum case if `self` is `.ok`.
        ///
        /// - Throws: An error if `self` is not `.ok`.
        /// - SeeAlso: `.ok`.
        public var ok: Operations.ChatMeMessage.Output.Ok {
            get throws {
                switch self {
                case let .ok(response):
                    return response
                default:
                    try throwUnexpectedResponseStatus(
                        expectedStatus: "ok",
                        response: self
                    )
                }
            }
        }
        /// Undocumented response.
        ///
        /// A response with a code that is not documented in the OpenAPI document.
        case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
    }
    @frozen public enum AcceptableContentType: AcceptableProtocol {
        case json
        case other(Swift.String)
        public init?(rawValue: Swift.String) {
            switch rawValue.lowercased() {
            case "application/json":
                self = .json
            default:
                self = .other(rawValue)
            }
        }
        public var rawValue: Swift.String {
            switch self {
            case let .other(string):
                return string
            case .json:
                return "application/json"
            }
        }
        public static var allCases: [Self] {
            [
                .json
            ]
        }
    }
}
public enum ChatPostEphemeral {
    public static let id: Swift.String = "chatPostEphemeral"
    public struct Input: Sendable, Hashable {
        /// - Remark: Generated from `#/paths/chat.postEphemeral/POST/header`.
        public struct Headers: Sendable, Hashable {
            public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ChatPostEphemeral.AcceptableContentType>]
            /// Creates a new `Headers`.
            ///
            /// - Parameters:
            ///   - accept:
            public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ChatPostEphemeral.AcceptableContentType>] = .defaultValues()) {
                self.accept = accept
            }
        }
        public var headers: Operations.ChatPostEphemeral.Input.Headers
        /// - Remark: Generated from `#/paths/chat.postEphemeral/POST/requestBody`.
        @frozen public enum Body: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/chat.postEphemeral/POST/requestBody/json`.
            public struct JsonPayload: Codable, Hashable, Sendable {
                /// Channel, private group, or IM channel to send message to. Can be an encoded ID, or a name.
                ///
                /// - Remark: Generated from `#/paths/chat.postEphemeral/POST/requestBody/json/channel`.
                public var channel: Swift.String
                /// id of the user who will receive the ephemeral message. The user should be in the channel specified by the channel argument.
                ///
                /// - Remark: Generated from `#/paths/chat.postEphemeral/POST/requestBody/json/user`.
                public var user: Swift.String
                /// A JSON-based array of structured attachments, presented as a URL-encoded string.
                ///
                /// - Remark: Generated from `#/paths/chat.postEphemeral/POST/requestBody/json/attachments`.
                public var attachments: Swift.String?
                /// A JSON-based array of structured blocks, presented as a URL-encoded string.
                ///
                /// - Remark: Generated from `#/paths/chat.postEphemeral/POST/requestBody/json/blocks`.
                public var blocks: Swift.String?
                /// How this field works and whether it is required depends on other fields you use in your API call. See below for more detail.
                ///
                /// - Remark: Generated from `#/paths/chat.postEphemeral/POST/requestBody/json/text`.
                public var text: Swift.String?
                /// (Legacy) Pass true to post the message as the authed user. Defaults to true if the chat:write:bot scope is not included. Otherwise, defaults to false.
                ///
                /// - Remark: Generated from `#/paths/chat.postEphemeral/POST/requestBody/json/asUser`.
                public var asUser: Swift.Bool?
                /// Emoji to use as the icon for this message. Overrides icon_url.
                ///
                /// - Remark: Generated from `#/paths/chat.postEphemeral/POST/requestBody/json/iconEmoji`.
                public var iconEmoji: Swift.String?
                /// URL to an image to use as the icon for this message.
                ///
                /// - Remark: Generated from `#/paths/chat.postEphemeral/POST/requestBody/json/iconUrl`.
                public var iconUrl: Swift.String?
                /// Find and link channel names and usernames.
                ///
                /// - Remark: Generated from `#/paths/chat.postEphemeral/POST/requestBody/json/linkNames`.
                public var linkNames: Swift.Bool?
                /// Accepts message text formatted in markdown. This argument should not be used in conjunction with blocks or text. Limit this field to 12,000 characters.
                ///
                /// - Remark: Generated from `#/paths/chat.postEphemeral/POST/requestBody/json/markdownText`.
                public var markdownText: Swift.String?
                /// Change how messages are treated. Defaults to none. See below.
                ///
                /// - Remark: Generated from `#/paths/chat.postEphemeral/POST/requestBody/json/parse`.
                public var parse: Swift.String?
                /// Provide another message's ts value to post this message in a thread. Avoid using a reply's ts value; use its parent's value instead. Ephemeral messages in threads are only shown if there is already an active thread.
                ///
                /// - Remark: Generated from `#/paths/chat.postEphemeral/POST/requestBody/json/threadTs`.
                public var threadTs: Swift.String?
                /// Set your bot's user name.
                ///
                /// - Remark: Generated from `#/paths/chat.postEphemeral/POST/requestBody/json/username`.
                public var username: Swift.String?
                /// Creates a new `JsonPayload`.
                ///
                /// - Parameters:
                ///   - channel: Channel, private group, or IM channel to send message to. Can be an encoded ID, or a name.
                ///   - user: id of the user who will receive the ephemeral message. The user should be in the channel specified by the channel argument.
                ///   - attachments: A JSON-based array of structured attachments, presented as a URL-encoded string.
                ///   - blocks: A JSON-based array of structured blocks, presented as a URL-encoded string.
                ///   - text: How this field works and whether it is required depends on other fields you use in your API call. See below for more detail.
                ///   - asUser: (Legacy) Pass true to post the message as the authed user. Defaults to true if the chat:write:bot scope is not included. Otherwise, defaults to false.
                ///   - iconEmoji: Emoji to use as the icon for this message. Overrides icon_url.
                ///   - iconUrl: URL to an image to use as the icon for this message.
                ///   - linkNames: Find and link channel names and usernames.
                ///   - markdownText: Accepts message text formatted in markdown. This argument should not be used in conjunction with blocks or text. Limit this field to 12,000 characters.
                ///   - parse: Change how messages are treated. Defaults to none. See below.
                ///   - threadTs: Provide another message's ts value to post this message in a thread. Avoid using a reply's ts value; use its parent's value instead. Ephemeral messages in threads are only shown if there is already an active thread.
                ///   - username: Set your bot's user name.
                public init(
                    channel: Swift.String,
                    user: Swift.String,
                    attachments: Swift.String? = nil,
                    blocks: Swift.String? = nil,
                    text: Swift.String? = nil,
                    asUser: Swift.Bool? = nil,
                    iconEmoji: Swift.String? = nil,
                    iconUrl: Swift.String? = nil,
                    linkNames: Swift.Bool? = nil,
                    markdownText: Swift.String? = nil,
                    parse: Swift.String? = nil,
                    threadTs: Swift.String? = nil,
                    username: Swift.String? = nil
                ) {
                    self.channel = channel
                    self.user = user
                    self.attachments = attachments
                    self.blocks = blocks
                    self.text = text
                    self.asUser = asUser
                    self.iconEmoji = iconEmoji
                    self.iconUrl = iconUrl
                    self.linkNames = linkNames
                    self.markdownText = markdownText
                    self.parse = parse
                    self.threadTs = threadTs
                    self.username = username
                }
                public enum CodingKeys: String, CodingKey {
                    case channel
                    case user
                    case attachments
                    case blocks
                    case text
                    case asUser
                    case iconEmoji
                    case iconUrl
                    case linkNames
                    case markdownText
                    case parse
                    case threadTs
                    case username
                }
            }
            /// - Remark: Generated from `#/paths/chat.postEphemeral/POST/requestBody/content/application\/json`.
            case json(Operations.ChatPostEphemeral.Input.Body.JsonPayload)
        }
        public var body: Operations.ChatPostEphemeral.Input.Body
        /// Creates a new `Input`.
        ///
        /// - Parameters:
        ///   - headers:
        ///   - body:
        public init(
            headers: Operations.ChatPostEphemeral.Input.Headers = .init(),
            body: Operations.ChatPostEphemeral.Input.Body
        ) {
            self.headers = headers
            self.body = body
        }
    }
    @frozen public enum Output: Sendable, Hashable {
        public struct Ok: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/chat.postEphemeral/POST/responses/200/content`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/chat.postEphemeral/POST/responses/200/content/application\/json`.
                case json(Components.Schemas.ChatPostEphemeralResponse)
                /// The associated value of the enum case if `self` is `.json`.
                ///
                /// - Throws: An error if `self` is not `.json`.
                /// - SeeAlso: `.json`.
                public var json: Components.Schemas.ChatPostEphemeralResponse {
                    get throws {
                        switch self {
                        case let .json(body):
                            return body
                        }
                    }
                }
            }
            /// Received HTTP response body
            public var body: Operations.ChatPostEphemeral.Output.Ok.Body
            /// Creates a new `Ok`.
            ///
            /// - Parameters:
            ///   - body: Received HTTP response body
            public init(body: Operations.ChatPostEphemeral.Output.Ok.Body) {
                self.body = body
            }
        }
        /// OK
        ///
        /// - Remark: Generated from `#/paths//chat.postEphemeral/post(chatPostEphemeral)/responses/200`.
        ///
        /// HTTP response code: `200 ok`.
        case ok(Operations.ChatPostEphemeral.Output.Ok)
        /// The associated value of the enum case if `self` is `.ok`.
        ///
        /// - Throws: An error if `self` is not `.ok`.
        /// - SeeAlso: `.ok`.
        public var ok: Operations.ChatPostEphemeral.Output.Ok {
            get throws {
                switch self {
                case let .ok(response):
                    return response
                default:
                    try throwUnexpectedResponseStatus(
                        expectedStatus: "ok",
                        response: self
                    )
                }
            }
        }
        /// Undocumented response.
        ///
        /// A response with a code that is not documented in the OpenAPI document.
        case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
    }
    @frozen public enum AcceptableContentType: AcceptableProtocol {
        case json
        case other(Swift.String)
        public init?(rawValue: Swift.String) {
            switch rawValue.lowercased() {
            case "application/json":
                self = .json
            default:
                self = .other(rawValue)
            }
        }
        public var rawValue: Swift.String {
            switch self {
            case let .other(string):
                return string
            case .json:
                return "application/json"
            }
        }
        public static var allCases: [Self] {
            [
                .json
            ]
        }
    }
}
public enum ChatPostMessage {
    public static let id: Swift.String = "chatPostMessage"
    public struct Input: Sendable, Hashable {
        /// - Remark: Generated from `#/paths/chat.postMessage/POST/header`.
        public struct Headers: Sendable, Hashable {
            public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ChatPostMessage.AcceptableContentType>]
            /// Creates a new `Headers`.
            ///
            /// - Parameters:
            ///   - accept:
            public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ChatPostMessage.AcceptableContentType>] = .defaultValues()) {
                self.accept = accept
            }
        }
        public var headers: Operations.ChatPostMessage.Input.Headers
        /// - Remark: Generated from `#/paths/chat.postMessage/POST/requestBody`.
        @frozen public enum Body: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/chat.postMessage/POST/requestBody/json`.
            public struct JsonPayload: Codable, Hashable, Sendable {
                /// An encoded ID or channel name that represents a channel, private group, or IM channel to send the message to. See below for more details.
                ///
                /// - Remark: Generated from `#/paths/chat.postMessage/POST/requestBody/json/channel`.
                public var channel: Swift.String
                /// A JSON-based array of structured attachments, presented as a URL-encoded string.
                ///
                /// - Remark: Generated from `#/paths/chat.postMessage/POST/requestBody/json/attachments`.
                public var attachments: Swift.String?
                /// A JSON-based array of structured blocks, presented as a URL-encoded string.
                ///
                /// - Remark: Generated from `#/paths/chat.postMessage/POST/requestBody/json/blocks`.
                public var blocks: Swift.String?
                /// How this field works and whether it is required depends on other fields you use in your API call. See below for more detail.
                ///
                /// - Remark: Generated from `#/paths/chat.postMessage/POST/requestBody/json/text`.
                public var text: Swift.String?
                /// Identify how the message was posted for agentforce BE logging.
                ///
                /// - Remark: Generated from `#/paths/chat.postMessage/POST/requestBody/json/agentMessageSourceType`.
                public var agentMessageSourceType: Swift.String?
                /// (Legacy) Pass true to post the message as the authed user instead of as a bot. Defaults to false. Can only be used by classic apps. See legacy as_user parameter below.
                ///
                /// - Remark: Generated from `#/paths/chat.postMessage/POST/requestBody/json/asUser`.
                public var asUser: Swift.Bool?
                /// Emoji to use as the icon for this message. Overrides icon_url.
                ///
                /// - Remark: Generated from `#/paths/chat.postMessage/POST/requestBody/json/iconEmoji`.
                public var iconEmoji: Swift.String?
                /// URL to an image to use as the icon for this message.
                ///
                /// - Remark: Generated from `#/paths/chat.postMessage/POST/requestBody/json/iconUrl`.
                public var iconUrl: Swift.String?
                /// Find and link user groups. No longer supports linking individual users; use syntax shown in Mentioning Users instead.
                ///
                /// - Remark: Generated from `#/paths/chat.postMessage/POST/requestBody/json/linkNames`.
                public var linkNames: Swift.Bool?
                /// Accepts message text formatted in markdown. This argument should not be used in conjunction with blocks or text. Limit this field to 12,000 characters.
                ///
                /// - Remark: Generated from `#/paths/chat.postMessage/POST/requestBody/json/markdownText`.
                public var markdownText: Swift.String?
                /// JSON object with event_type and event_payload fields, presented as a URL-encoded string. Metadata you post to Slack is accessible to any app or user who is a member of that workspace.
                ///
                /// - Remark: Generated from `#/paths/chat.postMessage/POST/requestBody/json/metadata`.
                public var metadata: Swift.String?
                /// Disable Slack markup parsing by setting to false. Enabled by default.
                ///
                /// - Remark: Generated from `#/paths/chat.postMessage/POST/requestBody/json/mrkdwn`.
                public var mrkdwn: Swift.Bool?
                /// Change how messages are treated. See below.
                ///
                /// - Remark: Generated from `#/paths/chat.postMessage/POST/requestBody/json/parse`.
                public var parse: Swift.String?
                /// Used in conjunction with thread_ts and indicates whether reply should be made visible to everyone in the channel or conversation. Defaults to false.
                ///
                /// - Remark: Generated from `#/paths/chat.postMessage/POST/requestBody/json/replyBroadcast`.
                public var replyBroadcast: Swift.Bool?
                /// Provide another message's ts value to make this message a reply. Avoid using a reply's ts value; use its parent instead.
                ///
                /// - Remark: Generated from `#/paths/chat.postMessage/POST/requestBody/json/threadTs`.
                public var threadTs: Swift.String?
                /// Pass true to enable unfurling of primarily text-based content.
                ///
                /// - Remark: Generated from `#/paths/chat.postMessage/POST/requestBody/json/unfurlLinks`.
                public var unfurlLinks: Swift.Bool?
                /// Pass false to disable unfurling of media content.
                ///
                /// - Remark: Generated from `#/paths/chat.postMessage/POST/requestBody/json/unfurlMedia`.
                public var unfurlMedia: Swift.Bool?
                /// Set your bot's user name.
                ///
                /// - Remark: Generated from `#/paths/chat.postMessage/POST/requestBody/json/username`.
                public var username: Swift.String?
                /// Creates a new `JsonPayload`.
                ///
                /// - Parameters:
                ///   - channel: An encoded ID or channel name that represents a channel, private group, or IM channel to send the message to. See below for more details.
                ///   - attachments: A JSON-based array of structured attachments, presented as a URL-encoded string.
                ///   - blocks: A JSON-based array of structured blocks, presented as a URL-encoded string.
                ///   - text: How this field works and whether it is required depends on other fields you use in your API call. See below for more detail.
                ///   - agentMessageSourceType: Identify how the message was posted for agentforce BE logging.
                ///   - asUser: (Legacy) Pass true to post the message as the authed user instead of as a bot. Defaults to false. Can only be used by classic apps. See legacy as_user parameter below.
                ///   - iconEmoji: Emoji to use as the icon for this message. Overrides icon_url.
                ///   - iconUrl: URL to an image to use as the icon for this message.
                ///   - linkNames: Find and link user groups. No longer supports linking individual users; use syntax shown in Mentioning Users instead.
                ///   - markdownText: Accepts message text formatted in markdown. This argument should not be used in conjunction with blocks or text. Limit this field to 12,000 characters.
                ///   - metadata: JSON object with event_type and event_payload fields, presented as a URL-encoded string. Metadata you post to Slack is accessible to any app or user who is a member of that workspace.
                ///   - mrkdwn: Disable Slack markup parsing by setting to false. Enabled by default.
                ///   - parse: Change how messages are treated. See below.
                ///   - replyBroadcast: Used in conjunction with thread_ts and indicates whether reply should be made visible to everyone in the channel or conversation. Defaults to false.
                ///   - threadTs: Provide another message's ts value to make this message a reply. Avoid using a reply's ts value; use its parent instead.
                ///   - unfurlLinks: Pass true to enable unfurling of primarily text-based content.
                ///   - unfurlMedia: Pass false to disable unfurling of media content.
                ///   - username: Set your bot's user name.
                public init(
                    channel: Swift.String,
                    attachments: Swift.String? = nil,
                    blocks: Swift.String? = nil,
                    text: Swift.String? = nil,
                    agentMessageSourceType: Swift.String? = nil,
                    asUser: Swift.Bool? = nil,
                    iconEmoji: Swift.String? = nil,
                    iconUrl: Swift.String? = nil,
                    linkNames: Swift.Bool? = nil,
                    markdownText: Swift.String? = nil,
                    metadata: Swift.String? = nil,
                    mrkdwn: Swift.Bool? = nil,
                    parse: Swift.String? = nil,
                    replyBroadcast: Swift.Bool? = nil,
                    threadTs: Swift.String? = nil,
                    unfurlLinks: Swift.Bool? = nil,
                    unfurlMedia: Swift.Bool? = nil,
                    username: Swift.String? = nil
                ) {
                    self.channel = channel
                    self.attachments = attachments
                    self.blocks = blocks
                    self.text = text
                    self.agentMessageSourceType = agentMessageSourceType
                    self.asUser = asUser
                    self.iconEmoji = iconEmoji
                    self.iconUrl = iconUrl
                    self.linkNames = linkNames
                    self.markdownText = markdownText
                    self.metadata = metadata
                    self.mrkdwn = mrkdwn
                    self.parse = parse
                    self.replyBroadcast = replyBroadcast
                    self.threadTs = threadTs
                    self.unfurlLinks = unfurlLinks
                    self.unfurlMedia = unfurlMedia
                    self.username = username
                }
                public enum CodingKeys: String, CodingKey {
                    case channel
                    case attachments
                    case blocks
                    case text
                    case agentMessageSourceType
                    case asUser
                    case iconEmoji
                    case iconUrl
                    case linkNames
                    case markdownText
                    case metadata
                    case mrkdwn
                    case parse
                    case replyBroadcast
                    case threadTs
                    case unfurlLinks
                    case unfurlMedia
                    case username
                }
            }
            /// - Remark: Generated from `#/paths/chat.postMessage/POST/requestBody/content/application\/json`.
            case json(Operations.ChatPostMessage.Input.Body.JsonPayload)
        }
        public var body: Operations.ChatPostMessage.Input.Body
        /// Creates a new `Input`.
        ///
        /// - Parameters:
        ///   - headers:
        ///   - body:
        public init(
            headers: Operations.ChatPostMessage.Input.Headers = .init(),
            body: Operations.ChatPostMessage.Input.Body
        ) {
            self.headers = headers
            self.body = body
        }
    }
    @frozen public enum Output: Sendable, Hashable {
        public struct Ok: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/chat.postMessage/POST/responses/200/content`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/chat.postMessage/POST/responses/200/content/application\/json`.
                case json(Components.Schemas.ChatPostMessageResponse)
                /// The associated value of the enum case if `self` is `.json`.
                ///
                /// - Throws: An error if `self` is not `.json`.
                /// - SeeAlso: `.json`.
                public var json: Components.Schemas.ChatPostMessageResponse {
                    get throws {
                        switch self {
                        case let .json(body):
                            return body
                        }
                    }
                }
            }
            /// Received HTTP response body
            public var body: Operations.ChatPostMessage.Output.Ok.Body
            /// Creates a new `Ok`.
            ///
            /// - Parameters:
            ///   - body: Received HTTP response body
            public init(body: Operations.ChatPostMessage.Output.Ok.Body) {
                self.body = body
            }
        }
        /// OK
        ///
        /// - Remark: Generated from `#/paths//chat.postMessage/post(chatPostMessage)/responses/200`.
        ///
        /// HTTP response code: `200 ok`.
        case ok(Operations.ChatPostMessage.Output.Ok)
        /// The associated value of the enum case if `self` is `.ok`.
        ///
        /// - Throws: An error if `self` is not `.ok`.
        /// - SeeAlso: `.ok`.
        public var ok: Operations.ChatPostMessage.Output.Ok {
            get throws {
                switch self {
                case let .ok(response):
                    return response
                default:
                    try throwUnexpectedResponseStatus(
                        expectedStatus: "ok",
                        response: self
                    )
                }
            }
        }
        /// Undocumented response.
        ///
        /// A response with a code that is not documented in the OpenAPI document.
        case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
    }
    @frozen public enum AcceptableContentType: AcceptableProtocol {
        case json
        case other(Swift.String)
        public init?(rawValue: Swift.String) {
            switch rawValue.lowercased() {
            case "application/json":
                self = .json
            default:
                self = .other(rawValue)
            }
        }
        public var rawValue: Swift.String {
            switch self {
            case let .other(string):
                return string
            case .json:
                return "application/json"
            }
        }
        public static var allCases: [Self] {
            [
                .json
            ]
        }
    }
}
public enum ChatScheduleMessage {
    public static let id: Swift.String = "chatScheduleMessage"
    public struct Input: Sendable, Hashable {
        /// - Remark: Generated from `#/paths/chat.scheduleMessage/POST/header`.
        public struct Headers: Sendable, Hashable {
            public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ChatScheduleMessage.AcceptableContentType>]
            /// Creates a new `Headers`.
            ///
            /// - Parameters:
            ///   - accept:
            public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ChatScheduleMessage.AcceptableContentType>] = .defaultValues()) {
                self.accept = accept
            }
        }
        public var headers: Operations.ChatScheduleMessage.Input.Headers
        /// - Remark: Generated from `#/paths/chat.scheduleMessage/POST/requestBody`.
        @frozen public enum Body: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/chat.scheduleMessage/POST/requestBody/json`.
            public struct JsonPayload: Codable, Hashable, Sendable {
                /// Channel, private group, or DM channel to send message to. Can be an encoded ID, or a name. See below for more details.
                ///
                /// - Remark: Generated from `#/paths/chat.scheduleMessage/POST/requestBody/json/channel`.
                public var channel: Swift.String
                /// Unix timestamp representing the future time the message should post to Slack.
                ///
                /// - Remark: Generated from `#/paths/chat.scheduleMessage/POST/requestBody/json/postAt`.
                public var postAt: Swift.Int
                /// A JSON-based array of structured attachments, presented as a URL-encoded string.
                ///
                /// - Remark: Generated from `#/paths/chat.scheduleMessage/POST/requestBody/json/attachments`.
                public var attachments: Swift.String?
                /// A JSON-based array of structured blocks, presented as a URL-encoded string.
                ///
                /// - Remark: Generated from `#/paths/chat.scheduleMessage/POST/requestBody/json/blocks`.
                public var blocks: Swift.String?
                /// How this field works and whether it is required depends on other fields you use in your API call. See below for more detail.
                ///
                /// - Remark: Generated from `#/paths/chat.scheduleMessage/POST/requestBody/json/text`.
                public var text: Swift.String?
                /// Set to true to post the message as the authed user, instead of as a bot. Defaults to false. Cannot be used by new Slack apps. See chat.postMessage.
                ///
                /// - Remark: Generated from `#/paths/chat.scheduleMessage/POST/requestBody/json/asUser`.
                public var asUser: Swift.Bool?
                /// Find and link user groups. No longer supports linking individual users; use syntax shown in Mentioning Users instead.
                ///
                /// - Remark: Generated from `#/paths/chat.scheduleMessage/POST/requestBody/json/linkNames`.
                public var linkNames: Swift.Bool?
                /// Accepts message text formatted in markdown. This argument should not be used in conjunction with blocks or text. Limit this field to 12,000 characters.
                ///
                /// - Remark: Generated from `#/paths/chat.scheduleMessage/POST/requestBody/json/markdownText`.
                public var markdownText: Swift.String?
                /// JSON object with event_type and event_payload fields, presented as a URL-encoded string. Metadata you post to Slack is accessible to any app or user who is a member of that workspace.
                ///
                /// - Remark: Generated from `#/paths/chat.scheduleMessage/POST/requestBody/json/metadata`.
                public var metadata: Swift.String?
                /// Change how messages are treated. See chat.postMessage.
                ///
                /// - Remark: Generated from `#/paths/chat.scheduleMessage/POST/requestBody/json/parse`.
                public var parse: Swift.String?
                /// Used in conjunction with thread_ts and indicates whether reply should be made visible to everyone in the channel or conversation. Defaults to false.
                ///
                /// - Remark: Generated from `#/paths/chat.scheduleMessage/POST/requestBody/json/replyBroadcast`.
                public var replyBroadcast: Swift.Bool?
                /// Provide another message's ts value to make this message a reply. Avoid using a reply's ts value; use its parent instead.
                ///
                /// - Remark: Generated from `#/paths/chat.scheduleMessage/POST/requestBody/json/threadTs`.
                public var threadTs: Swift.String?
                /// Pass true to enable unfurling of primarily text-based content.
                ///
                /// - Remark: Generated from `#/paths/chat.scheduleMessage/POST/requestBody/json/unfurlLinks`.
                public var unfurlLinks: Swift.Bool?
                /// Pass false to disable unfurling of media content.
                ///
                /// - Remark: Generated from `#/paths/chat.scheduleMessage/POST/requestBody/json/unfurlMedia`.
                public var unfurlMedia: Swift.Bool?
                /// Creates a new `JsonPayload`.
                ///
                /// - Parameters:
                ///   - channel: Channel, private group, or DM channel to send message to. Can be an encoded ID, or a name. See below for more details.
                ///   - postAt: Unix timestamp representing the future time the message should post to Slack.
                ///   - attachments: A JSON-based array of structured attachments, presented as a URL-encoded string.
                ///   - blocks: A JSON-based array of structured blocks, presented as a URL-encoded string.
                ///   - text: How this field works and whether it is required depends on other fields you use in your API call. See below for more detail.
                ///   - asUser: Set to true to post the message as the authed user, instead of as a bot. Defaults to false. Cannot be used by new Slack apps. See chat.postMessage.
                ///   - linkNames: Find and link user groups. No longer supports linking individual users; use syntax shown in Mentioning Users instead.
                ///   - markdownText: Accepts message text formatted in markdown. This argument should not be used in conjunction with blocks or text. Limit this field to 12,000 characters.
                ///   - metadata: JSON object with event_type and event_payload fields, presented as a URL-encoded string. Metadata you post to Slack is accessible to any app or user who is a member of that workspace.
                ///   - parse: Change how messages are treated. See chat.postMessage.
                ///   - replyBroadcast: Used in conjunction with thread_ts and indicates whether reply should be made visible to everyone in the channel or conversation. Defaults to false.
                ///   - threadTs: Provide another message's ts value to make this message a reply. Avoid using a reply's ts value; use its parent instead.
                ///   - unfurlLinks: Pass true to enable unfurling of primarily text-based content.
                ///   - unfurlMedia: Pass false to disable unfurling of media content.
                public init(
                    channel: Swift.String,
                    postAt: Swift.Int,
                    attachments: Swift.String? = nil,
                    blocks: Swift.String? = nil,
                    text: Swift.String? = nil,
                    asUser: Swift.Bool? = nil,
                    linkNames: Swift.Bool? = nil,
                    markdownText: Swift.String? = nil,
                    metadata: Swift.String? = nil,
                    parse: Swift.String? = nil,
                    replyBroadcast: Swift.Bool? = nil,
                    threadTs: Swift.String? = nil,
                    unfurlLinks: Swift.Bool? = nil,
                    unfurlMedia: Swift.Bool? = nil
                ) {
                    self.channel = channel
                    self.postAt = postAt
                    self.attachments = attachments
                    self.blocks = blocks
                    self.text = text
                    self.asUser = asUser
                    self.linkNames = linkNames
                    self.markdownText = markdownText
                    self.metadata = metadata
                    self.parse = parse
                    self.replyBroadcast = replyBroadcast
                    self.threadTs = threadTs
                    self.unfurlLinks = unfurlLinks
                    self.unfurlMedia = unfurlMedia
                }
                public enum CodingKeys: String, CodingKey {
                    case channel
                    case postAt
                    case attachments
                    case blocks
                    case text
                    case asUser
                    case linkNames
                    case markdownText
                    case metadata
                    case parse
                    case replyBroadcast
                    case threadTs
                    case unfurlLinks
                    case unfurlMedia
                }
            }
            /// - Remark: Generated from `#/paths/chat.scheduleMessage/POST/requestBody/content/application\/json`.
            case json(Operations.ChatScheduleMessage.Input.Body.JsonPayload)
        }
        public var body: Operations.ChatScheduleMessage.Input.Body
        /// Creates a new `Input`.
        ///
        /// - Parameters:
        ///   - headers:
        ///   - body:
        public init(
            headers: Operations.ChatScheduleMessage.Input.Headers = .init(),
            body: Operations.ChatScheduleMessage.Input.Body
        ) {
            self.headers = headers
            self.body = body
        }
    }
    @frozen public enum Output: Sendable, Hashable {
        public struct Ok: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/chat.scheduleMessage/POST/responses/200/content`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/chat.scheduleMessage/POST/responses/200/content/application\/json`.
                case json(Components.Schemas.ChatScheduleMessageResponse)
                /// The associated value of the enum case if `self` is `.json`.
                ///
                /// - Throws: An error if `self` is not `.json`.
                /// - SeeAlso: `.json`.
                public var json: Components.Schemas.ChatScheduleMessageResponse {
                    get throws {
                        switch self {
                        case let .json(body):
                            return body
                        }
                    }
                }
            }
            /// Received HTTP response body
            public var body: Operations.ChatScheduleMessage.Output.Ok.Body
            /// Creates a new `Ok`.
            ///
            /// - Parameters:
            ///   - body: Received HTTP response body
            public init(body: Operations.ChatScheduleMessage.Output.Ok.Body) {
                self.body = body
            }
        }
        /// OK
        ///
        /// - Remark: Generated from `#/paths//chat.scheduleMessage/post(chatScheduleMessage)/responses/200`.
        ///
        /// HTTP response code: `200 ok`.
        case ok(Operations.ChatScheduleMessage.Output.Ok)
        /// The associated value of the enum case if `self` is `.ok`.
        ///
        /// - Throws: An error if `self` is not `.ok`.
        /// - SeeAlso: `.ok`.
        public var ok: Operations.ChatScheduleMessage.Output.Ok {
            get throws {
                switch self {
                case let .ok(response):
                    return response
                default:
                    try throwUnexpectedResponseStatus(
                        expectedStatus: "ok",
                        response: self
                    )
                }
            }
        }
        /// Undocumented response.
        ///
        /// A response with a code that is not documented in the OpenAPI document.
        case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
    }
    @frozen public enum AcceptableContentType: AcceptableProtocol {
        case json
        case other(Swift.String)
        public init?(rawValue: Swift.String) {
            switch rawValue.lowercased() {
            case "application/json":
                self = .json
            default:
                self = .other(rawValue)
            }
        }
        public var rawValue: Swift.String {
            switch self {
            case let .other(string):
                return string
            case .json:
                return "application/json"
            }
        }
        public static var allCases: [Self] {
            [
                .json
            ]
        }
    }
}
public enum ChatScheduledMessagesList {
    public static let id: Swift.String = "chatScheduledMessagesList"
    public struct Input: Sendable, Hashable {
        /// - Remark: Generated from `#/paths/chat.scheduledMessages.list/POST/header`.
        public struct Headers: Sendable, Hashable {
            public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ChatScheduledMessagesList.AcceptableContentType>]
            /// Creates a new `Headers`.
            ///
            /// - Parameters:
            ///   - accept:
            public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ChatScheduledMessagesList.AcceptableContentType>] = .defaultValues()) {
                self.accept = accept
            }
        }
        public var headers: Operations.ChatScheduledMessagesList.Input.Headers
        /// - Remark: Generated from `#/paths/chat.scheduledMessages.list/POST/requestBody`.
        @frozen public enum Body: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/chat.scheduledMessages.list/POST/requestBody/json`.
            public struct JsonPayload: Codable, Hashable, Sendable {
                /// The channel of the scheduled messages.
                ///
                /// - Remark: Generated from `#/paths/chat.scheduledMessages.list/POST/requestBody/json/channel`.
                public var channel: Swift.String?
                /// For pagination purposes, this is the cursor value returned from a previous call to chat.scheduledmessages.list indicating where you want to start this call from.
                ///
                /// - Remark: Generated from `#/paths/chat.scheduledMessages.list/POST/requestBody/json/cursor`.
                public var cursor: Swift.String?
                /// A Unix timestamp of the latest value in the time range.
                ///
                /// - Remark: Generated from `#/paths/chat.scheduledMessages.list/POST/requestBody/json/latest`.
                public var latest: Swift.String?
                /// Maximum number of original entries to return.
                ///
                /// - Remark: Generated from `#/paths/chat.scheduledMessages.list/POST/requestBody/json/limit`.
                public var limit: Swift.Int?
                /// A Unix timestamp of the oldest value in the time range.
                ///
                /// - Remark: Generated from `#/paths/chat.scheduledMessages.list/POST/requestBody/json/oldest`.
                public var oldest: Swift.String?
                /// encoded team id to list channels in, required if org token is used.
                ///
                /// - Remark: Generated from `#/paths/chat.scheduledMessages.list/POST/requestBody/json/teamId`.
                public var teamId: Swift.String?
                /// Creates a new `JsonPayload`.
                ///
                /// - Parameters:
                ///   - channel: The channel of the scheduled messages.
                ///   - cursor: For pagination purposes, this is the cursor value returned from a previous call to chat.scheduledmessages.list indicating where you want to start this call from.
                ///   - latest: A Unix timestamp of the latest value in the time range.
                ///   - limit: Maximum number of original entries to return.
                ///   - oldest: A Unix timestamp of the oldest value in the time range.
                ///   - teamId: encoded team id to list channels in, required if org token is used.
                public init(
                    channel: Swift.String? = nil,
                    cursor: Swift.String? = nil,
                    latest: Swift.String? = nil,
                    limit: Swift.Int? = nil,
                    oldest: Swift.String? = nil,
                    teamId: Swift.String? = nil
                ) {
                    self.channel = channel
                    self.cursor = cursor
                    self.latest = latest
                    self.limit = limit
                    self.oldest = oldest
                    self.teamId = teamId
                }
                public enum CodingKeys: String, CodingKey {
                    case channel
                    case cursor
                    case latest
                    case limit
                    case oldest
                    case teamId
                }
            }
            /// - Remark: Generated from `#/paths/chat.scheduledMessages.list/POST/requestBody/content/application\/json`.
            case json(Operations.ChatScheduledMessagesList.Input.Body.JsonPayload)
        }
        public var body: Operations.ChatScheduledMessagesList.Input.Body
        /// Creates a new `Input`.
        ///
        /// - Parameters:
        ///   - headers:
        ///   - body:
        public init(
            headers: Operations.ChatScheduledMessagesList.Input.Headers = .init(),
            body: Operations.ChatScheduledMessagesList.Input.Body
        ) {
            self.headers = headers
            self.body = body
        }
    }
    @frozen public enum Output: Sendable, Hashable {
        public struct Ok: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/chat.scheduledMessages.list/POST/responses/200/content`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/chat.scheduledMessages.list/POST/responses/200/content/application\/json`.
                case json(Components.Schemas.ChatScheduledMessagesListResponse)
                /// The associated value of the enum case if `self` is `.json`.
                ///
                /// - Throws: An error if `self` is not `.json`.
                /// - SeeAlso: `.json`.
                public var json: Components.Schemas.ChatScheduledMessagesListResponse {
                    get throws {
                        switch self {
                        case let .json(body):
                            return body
                        }
                    }
                }
            }
            /// Received HTTP response body
            public var body: Operations.ChatScheduledMessagesList.Output.Ok.Body
            /// Creates a new `Ok`.
            ///
            /// - Parameters:
            ///   - body: Received HTTP response body
            public init(body: Operations.ChatScheduledMessagesList.Output.Ok.Body) {
                self.body = body
            }
        }
        /// OK
        ///
        /// - Remark: Generated from `#/paths//chat.scheduledMessages.list/post(chatScheduledMessagesList)/responses/200`.
        ///
        /// HTTP response code: `200 ok`.
        case ok(Operations.ChatScheduledMessagesList.Output.Ok)
        /// The associated value of the enum case if `self` is `.ok`.
        ///
        /// - Throws: An error if `self` is not `.ok`.
        /// - SeeAlso: `.ok`.
        public var ok: Operations.ChatScheduledMessagesList.Output.Ok {
            get throws {
                switch self {
                case let .ok(response):
                    return response
                default:
                    try throwUnexpectedResponseStatus(
                        expectedStatus: "ok",
                        response: self
                    )
                }
            }
        }
        /// Undocumented response.
        ///
        /// A response with a code that is not documented in the OpenAPI document.
        case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
    }
    @frozen public enum AcceptableContentType: AcceptableProtocol {
        case json
        case other(Swift.String)
        public init?(rawValue: Swift.String) {
            switch rawValue.lowercased() {
            case "application/json":
                self = .json
            default:
                self = .other(rawValue)
            }
        }
        public var rawValue: Swift.String {
            switch self {
            case let .other(string):
                return string
            case .json:
                return "application/json"
            }
        }
        public static var allCases: [Self] {
            [
                .json
            ]
        }
    }
}
public enum ChatUnfurl {
    public static let id: Swift.String = "chatUnfurl"
    public struct Input: Sendable, Hashable {
        /// - Remark: Generated from `#/paths/chat.unfurl/POST/header`.
        public struct Headers: Sendable, Hashable {
            public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ChatUnfurl.AcceptableContentType>]
            /// Creates a new `Headers`.
            ///
            /// - Parameters:
            ///   - accept:
            public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ChatUnfurl.AcceptableContentType>] = .defaultValues()) {
                self.accept = accept
            }
        }
        public var headers: Operations.ChatUnfurl.Input.Headers
        /// - Remark: Generated from `#/paths/chat.unfurl/POST/requestBody`.
        @frozen public enum Body: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/chat.unfurl/POST/requestBody/json`.
            public struct JsonPayload: Codable, Hashable, Sendable {
                /// Channel ID of the message. Both channel and ts must be provided together, or unfurl_id and source must be provided together.
                ///
                /// - Remark: Generated from `#/paths/chat.unfurl/POST/requestBody/json/channel`.
                public var channel: Swift.String
                /// Timestamp of the message to add unfurl behavior to.
                ///
                /// - Remark: Generated from `#/paths/chat.unfurl/POST/requestBody/json/ts`.
                public var ts: Swift.String
                /// URL-encoded JSON map with keys set to URLs featured in the the message, pointing to their unfurl blocks or message attachments.
                ///
                /// - Remark: Generated from `#/paths/chat.unfurl/POST/requestBody/json/unfurls`.
                public var unfurls: Swift.String
                /// The source of the link to unfurl. The source may either be composer, when the link is inside the message composer, or conversations_history, when the link has been posted to a conversation.
                ///
                /// - Remark: Generated from `#/paths/chat.unfurl/POST/requestBody/json/source`.
                public var source: Swift.String?
                /// The ID of the link to unfurl. Both unfurl_id and source must be provided together, or channel and ts must be provided together.
                ///
                /// - Remark: Generated from `#/paths/chat.unfurl/POST/requestBody/json/unfurlId`.
                public var unfurlId: Swift.String?
                /// Provide a JSON based array of structured blocks presented as URL-encoded string to send as an ephemeral message to the user as invitation to authenticate further and enable full unfurling behavior.
                ///
                /// - Remark: Generated from `#/paths/chat.unfurl/POST/requestBody/json/userAuthBlocks`.
                public var userAuthBlocks: Swift.String?
                /// Provide a simply-formatted string to send as an ephemeral message to the user as invitation to authenticate further and enable full unfurling behavior. Provides two buttons, Not now or Never ask me again.
                ///
                /// - Remark: Generated from `#/paths/chat.unfurl/POST/requestBody/json/userAuthMessage`.
                public var userAuthMessage: Swift.String?
                /// Set to true or 1 to indicate the user must install your Slack app to trigger unfurls for this domain.
                ///
                /// - Remark: Generated from `#/paths/chat.unfurl/POST/requestBody/json/userAuthRequired`.
                public var userAuthRequired: Swift.Bool?
                /// Send users to this custom URL where they will complete authentication in your app to fully trigger unfurling. Value should be properly URL-encoded.
                ///
                /// - Remark: Generated from `#/paths/chat.unfurl/POST/requestBody/json/userAuthUrl`.
                public var userAuthUrl: Swift.String?
                /// Creates a new `JsonPayload`.
                ///
                /// - Parameters:
                ///   - channel: Channel ID of the message. Both channel and ts must be provided together, or unfurl_id and source must be provided together.
                ///   - ts: Timestamp of the message to add unfurl behavior to.
                ///   - unfurls: URL-encoded JSON map with keys set to URLs featured in the the message, pointing to their unfurl blocks or message attachments.
                ///   - source: The source of the link to unfurl. The source may either be composer, when the link is inside the message composer, or conversations_history, when the link has been posted to a conversation.
                ///   - unfurlId: The ID of the link to unfurl. Both unfurl_id and source must be provided together, or channel and ts must be provided together.
                ///   - userAuthBlocks: Provide a JSON based array of structured blocks presented as URL-encoded string to send as an ephemeral message to the user as invitation to authenticate further and enable full unfurling behavior.
                ///   - userAuthMessage: Provide a simply-formatted string to send as an ephemeral message to the user as invitation to authenticate further and enable full unfurling behavior. Provides two buttons, Not now or Never ask me again.
                ///   - userAuthRequired: Set to true or 1 to indicate the user must install your Slack app to trigger unfurls for this domain.
                ///   - userAuthUrl: Send users to this custom URL where they will complete authentication in your app to fully trigger unfurling. Value should be properly URL-encoded.
                public init(
                    channel: Swift.String,
                    ts: Swift.String,
                    unfurls: Swift.String,
                    source: Swift.String? = nil,
                    unfurlId: Swift.String? = nil,
                    userAuthBlocks: Swift.String? = nil,
                    userAuthMessage: Swift.String? = nil,
                    userAuthRequired: Swift.Bool? = nil,
                    userAuthUrl: Swift.String? = nil
                ) {
                    self.channel = channel
                    self.ts = ts
                    self.unfurls = unfurls
                    self.source = source
                    self.unfurlId = unfurlId
                    self.userAuthBlocks = userAuthBlocks
                    self.userAuthMessage = userAuthMessage
                    self.userAuthRequired = userAuthRequired
                    self.userAuthUrl = userAuthUrl
                }
                public enum CodingKeys: String, CodingKey {
                    case channel
                    case ts
                    case unfurls
                    case source
                    case unfurlId
                    case userAuthBlocks
                    case userAuthMessage
                    case userAuthRequired
                    case userAuthUrl
                }
            }
            /// - Remark: Generated from `#/paths/chat.unfurl/POST/requestBody/content/application\/json`.
            case json(Operations.ChatUnfurl.Input.Body.JsonPayload)
        }
        public var body: Operations.ChatUnfurl.Input.Body
        /// Creates a new `Input`.
        ///
        /// - Parameters:
        ///   - headers:
        ///   - body:
        public init(
            headers: Operations.ChatUnfurl.Input.Headers = .init(),
            body: Operations.ChatUnfurl.Input.Body
        ) {
            self.headers = headers
            self.body = body
        }
    }
    @frozen public enum Output: Sendable, Hashable {
        public struct Ok: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/chat.unfurl/POST/responses/200/content`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/chat.unfurl/POST/responses/200/content/application\/json`.
                case json(Components.Schemas.ChatUnfurlResponse)
                /// The associated value of the enum case if `self` is `.json`.
                ///
                /// - Throws: An error if `self` is not `.json`.
                /// - SeeAlso: `.json`.
                public var json: Components.Schemas.ChatUnfurlResponse {
                    get throws {
                        switch self {
                        case let .json(body):
                            return body
                        }
                    }
                }
            }
            /// Received HTTP response body
            public var body: Operations.ChatUnfurl.Output.Ok.Body
            /// Creates a new `Ok`.
            ///
            /// - Parameters:
            ///   - body: Received HTTP response body
            public init(body: Operations.ChatUnfurl.Output.Ok.Body) {
                self.body = body
            }
        }
        /// OK
        ///
        /// - Remark: Generated from `#/paths//chat.unfurl/post(chatUnfurl)/responses/200`.
        ///
        /// HTTP response code: `200 ok`.
        case ok(Operations.ChatUnfurl.Output.Ok)
        /// The associated value of the enum case if `self` is `.ok`.
        ///
        /// - Throws: An error if `self` is not `.ok`.
        /// - SeeAlso: `.ok`.
        public var ok: Operations.ChatUnfurl.Output.Ok {
            get throws {
                switch self {
                case let .ok(response):
                    return response
                default:
                    try throwUnexpectedResponseStatus(
                        expectedStatus: "ok",
                        response: self
                    )
                }
            }
        }
        /// Undocumented response.
        ///
        /// A response with a code that is not documented in the OpenAPI document.
        case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
    }
    @frozen public enum AcceptableContentType: AcceptableProtocol {
        case json
        case other(Swift.String)
        public init?(rawValue: Swift.String) {
            switch rawValue.lowercased() {
            case "application/json":
                self = .json
            default:
                self = .other(rawValue)
            }
        }
        public var rawValue: Swift.String {
            switch self {
            case let .other(string):
                return string
            case .json:
                return "application/json"
            }
        }
        public static var allCases: [Self] {
            [
                .json
            ]
        }
    }
}
public enum ChatUpdate {
    public static let id: Swift.String = "chatUpdate"
    public struct Input: Sendable, Hashable {
        /// - Remark: Generated from `#/paths/chat.update/POST/header`.
        public struct Headers: Sendable, Hashable {
            public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ChatUpdate.AcceptableContentType>]
            /// Creates a new `Headers`.
            ///
            /// - Parameters:
            ///   - accept:
            public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ChatUpdate.AcceptableContentType>] = .defaultValues()) {
                self.accept = accept
            }
        }
        public var headers: Operations.ChatUpdate.Input.Headers
        /// - Remark: Generated from `#/paths/chat.update/POST/requestBody`.
        @frozen public enum Body: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/chat.update/POST/requestBody/json`.
            public struct JsonPayload: Codable, Hashable, Sendable {
                /// Channel containing the message to be updated. For direct messages, ensure that this value is a DM ID (starts with D) instead of a User ID (starts with either U or W).
                ///
                /// - Remark: Generated from `#/paths/chat.update/POST/requestBody/json/channel`.
                public var channel: Swift.String
                /// Timestamp of the message to be updated.
                ///
                /// - Remark: Generated from `#/paths/chat.update/POST/requestBody/json/ts`.
                public var ts: Swift.String
                /// A JSON-based array of structured attachments, presented as a URL-encoded string.
                ///
                /// - Remark: Generated from `#/paths/chat.update/POST/requestBody/json/attachments`.
                public var attachments: Swift.String?
                /// A JSON-based array of structured blocks, presented as a URL-encoded string.
                ///
                /// - Remark: Generated from `#/paths/chat.update/POST/requestBody/json/blocks`.
                public var blocks: Swift.String?
                /// How this field works and whether it is required depends on other fields you use in your API call. See below for more detail.
                ///
                /// - Remark: Generated from `#/paths/chat.update/POST/requestBody/json/text`.
                public var text: Swift.String?
                /// Pass true to update the message as the authed user. Bot users in this context are considered authed users.
                ///
                /// - Remark: Generated from `#/paths/chat.update/POST/requestBody/json/asUser`.
                public var asUser: Swift.Bool?
                /// Array of new file ids that will be sent with this message.
                ///
                /// - Remark: Generated from `#/paths/chat.update/POST/requestBody/json/fileIds`.
                public var fileIds: OpenAPIRuntime.OpenAPIArrayContainer?
                /// Find and link channel names and usernames. Defaults to none. If you do not specify a value for this field, the original value set for the message will be overwritten with the default, none.
                ///
                /// - Remark: Generated from `#/paths/chat.update/POST/requestBody/json/linkNames`.
                public var linkNames: Swift.Bool?
                /// Accepts message text formatted in markdown. This argument should not be used in conjunction with blocks or text. Limit this field to 12,000 characters.
                ///
                /// - Remark: Generated from `#/paths/chat.update/POST/requestBody/json/markdownText`.
                public var markdownText: Swift.String?
                /// JSON object with event_type and event_payload fields, presented as a URL-encoded string. If you don't include this field, the message's previous metadata will be retained. To remove previous metadata, include an empty object for this field. Metadata you post to Slack is accessible to any app or user who is a member of that workspace.
                ///
                /// - Remark: Generated from `#/paths/chat.update/POST/requestBody/json/metadata`.
                public var metadata: Swift.String?
                /// Change how messages are treated. Defaults to client, unlike chat.postMessage. Accepts either none or full. If you do not specify a value for this field, the original value set for the message will be overwritten with the default, client.
                ///
                /// - Remark: Generated from `#/paths/chat.update/POST/requestBody/json/parse`.
                public var parse: Swift.String?
                /// Broadcast an existing thread reply to make it visible to everyone in the channel or conversation.
                ///
                /// - Remark: Generated from `#/paths/chat.update/POST/requestBody/json/replyBroadcast`.
                public var replyBroadcast: Swift.Bool?
                /// Creates a new `JsonPayload`.
                ///
                /// - Parameters:
                ///   - channel: Channel containing the message to be updated. For direct messages, ensure that this value is a DM ID (starts with D) instead of a User ID (starts with either U or W).
                ///   - ts: Timestamp of the message to be updated.
                ///   - attachments: A JSON-based array of structured attachments, presented as a URL-encoded string.
                ///   - blocks: A JSON-based array of structured blocks, presented as a URL-encoded string.
                ///   - text: How this field works and whether it is required depends on other fields you use in your API call. See below for more detail.
                ///   - asUser: Pass true to update the message as the authed user. Bot users in this context are considered authed users.
                ///   - fileIds: Array of new file ids that will be sent with this message.
                ///   - linkNames: Find and link channel names and usernames. Defaults to none. If you do not specify a value for this field, the original value set for the message will be overwritten with the default, none.
                ///   - markdownText: Accepts message text formatted in markdown. This argument should not be used in conjunction with blocks or text. Limit this field to 12,000 characters.
                ///   - metadata: JSON object with event_type and event_payload fields, presented as a URL-encoded string. If you don't include this field, the message's previous metadata will be retained. To remove previous metadata, include an empty object for this field. Metadata you post to Slack is accessible to any app or user who is a member of that workspace.
                ///   - parse: Change how messages are treated. Defaults to client, unlike chat.postMessage. Accepts either none or full. If you do not specify a value for this field, the original value set for the message will be overwritten with the default, client.
                ///   - replyBroadcast: Broadcast an existing thread reply to make it visible to everyone in the channel or conversation.
                public init(
                    channel: Swift.String,
                    ts: Swift.String,
                    attachments: Swift.String? = nil,
                    blocks: Swift.String? = nil,
                    text: Swift.String? = nil,
                    asUser: Swift.Bool? = nil,
                    fileIds: OpenAPIRuntime.OpenAPIArrayContainer? = nil,
                    linkNames: Swift.Bool? = nil,
                    markdownText: Swift.String? = nil,
                    metadata: Swift.String? = nil,
                    parse: Swift.String? = nil,
                    replyBroadcast: Swift.Bool? = nil
                ) {
                    self.channel = channel
                    self.ts = ts
                    self.attachments = attachments
                    self.blocks = blocks
                    self.text = text
                    self.asUser = asUser
                    self.fileIds = fileIds
                    self.linkNames = linkNames
                    self.markdownText = markdownText
                    self.metadata = metadata
                    self.parse = parse
                    self.replyBroadcast = replyBroadcast
                }
                public enum CodingKeys: String, CodingKey {
                    case channel
                    case ts
                    case attachments
                    case blocks
                    case text
                    case asUser
                    case fileIds
                    case linkNames
                    case markdownText
                    case metadata
                    case parse
                    case replyBroadcast
                }
            }
            /// - Remark: Generated from `#/paths/chat.update/POST/requestBody/content/application\/json`.
            case json(Operations.ChatUpdate.Input.Body.JsonPayload)
        }
        public var body: Operations.ChatUpdate.Input.Body
        /// Creates a new `Input`.
        ///
        /// - Parameters:
        ///   - headers:
        ///   - body:
        public init(
            headers: Operations.ChatUpdate.Input.Headers = .init(),
            body: Operations.ChatUpdate.Input.Body
        ) {
            self.headers = headers
            self.body = body
        }
    }
    @frozen public enum Output: Sendable, Hashable {
        public struct Ok: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/chat.update/POST/responses/200/content`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/chat.update/POST/responses/200/content/application\/json`.
                case json(Components.Schemas.ChatUpdateResponse)
                /// The associated value of the enum case if `self` is `.json`.
                ///
                /// - Throws: An error if `self` is not `.json`.
                /// - SeeAlso: `.json`.
                public var json: Components.Schemas.ChatUpdateResponse {
                    get throws {
                        switch self {
                        case let .json(body):
                            return body
                        }
                    }
                }
            }
            /// Received HTTP response body
            public var body: Operations.ChatUpdate.Output.Ok.Body
            /// Creates a new `Ok`.
            ///
            /// - Parameters:
            ///   - body: Received HTTP response body
            public init(body: Operations.ChatUpdate.Output.Ok.Body) {
                self.body = body
            }
        }
        /// OK
        ///
        /// - Remark: Generated from `#/paths//chat.update/post(chatUpdate)/responses/200`.
        ///
        /// HTTP response code: `200 ok`.
        case ok(Operations.ChatUpdate.Output.Ok)
        /// The associated value of the enum case if `self` is `.ok`.
        ///
        /// - Throws: An error if `self` is not `.ok`.
        /// - SeeAlso: `.ok`.
        public var ok: Operations.ChatUpdate.Output.Ok {
            get throws {
                switch self {
                case let .ok(response):
                    return response
                default:
                    try throwUnexpectedResponseStatus(
                        expectedStatus: "ok",
                        response: self
                    )
                }
            }
        }
        /// Undocumented response.
        ///
        /// A response with a code that is not documented in the OpenAPI document.
        case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
    }
    @frozen public enum AcceptableContentType: AcceptableProtocol {
        case json
        case other(Swift.String)
        public init?(rawValue: Swift.String) {
            switch rawValue.lowercased() {
            case "application/json":
                self = .json
            default:
                self = .other(rawValue)
            }
        }
        public var rawValue: Swift.String {
            switch self {
            case let .other(string):
                return string
            case .json:
                return "application/json"
            }
        }
        public static var allCases: [Self] {
            [
                .json
            ]
        }
    }
}
}
#endif
