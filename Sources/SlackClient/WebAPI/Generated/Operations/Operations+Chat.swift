// Generated by swift-openapi-generator, do not modify.
@_spi(Generated) import OpenAPIRuntime
#if os(Linux)
@preconcurrency import struct Foundation.Data
@preconcurrency import struct Foundation.Date
@preconcurrency import struct Foundation.URL
#else
import struct Foundation.Data
import struct Foundation.Date
import struct Foundation.URL
#endif

#if canImport(SlackBlockKit)
import SlackBlockKit
#endif

#if canImport(SlackModels)
import SlackModels
#endif
/// API operations, with input and output types, generated from `#/paths` in the OpenAPI document.

#if WebAPI_Chat
extension Operations {
    public enum ChatPostEphemeral {
        public static let id: Swift.String = "chatPostEphemeral"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/chat.postEphemeral/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ChatPostEphemeral.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ChatPostEphemeral.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }

            public var headers: Operations.ChatPostEphemeral.Input.Headers
            /// - Remark: Generated from `#/paths/chat.postEphemeral/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/chat.postEphemeral/POST/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// (Legacy) Pass true to post the message as the authed user. Defaults to true if the chat:write:bot scope is not included. Otherwise, defaults to false.
                    ///
                    /// - Remark: Generated from `#/paths/chat.postEphemeral/POST/requestBody/json/as_user`.
                    public var asUser: Swift.Bool?
                    /// A JSON-based array of structured attachments, presented as a URL-encoded string.
                    ///
                    /// - Remark: Generated from `#/paths/chat.postEphemeral/POST/requestBody/json/attachments`.
                    public var attachments: [SlackModels.Attachment]?
                    /// A JSON-based array of structured blocks, presented as a URL-encoded string.
                    ///
                    /// - Remark: Generated from `#/paths/chat.postEphemeral/POST/requestBody/json/blocks`.
                    public var blocks: [SlackBlockKit.Block]?
                    /// Channel, private group, or IM channel to send message to. Can be an encoded ID, or a name.
                    ///
                    /// - Remark: Generated from `#/paths/chat.postEphemeral/POST/requestBody/json/channel`.
                    public var channel: Swift.String
                    /// Emoji to use as the icon for this message. Overrides icon_url.
                    ///
                    /// - Remark: Generated from `#/paths/chat.postEphemeral/POST/requestBody/json/icon_emoji`.
                    public var iconEmoji: Swift.String?
                    /// URL to an image to use as the icon for this message.
                    ///
                    /// - Remark: Generated from `#/paths/chat.postEphemeral/POST/requestBody/json/icon_url`.
                    public var iconUrl: Swift.String?
                    /// Find and link channel names and usernames.
                    ///
                    /// - Remark: Generated from `#/paths/chat.postEphemeral/POST/requestBody/json/link_names`.
                    public var linkNames: Swift.Bool?
                    /// Accepts message text formatted in markdown. This argument should not be used in conjunction with blocks or text. Limit this field to 12,000 characters.
                    ///
                    /// - Remark: Generated from `#/paths/chat.postEphemeral/POST/requestBody/json/markdown_text`.
                    public var markdownText: Swift.String?
                    /// Change how messages are treated. Defaults to none. See below.
                    ///
                    /// - Remark: Generated from `#/paths/chat.postEphemeral/POST/requestBody/json/parse`.
                    public var parse: Swift.String?
                    /// How this field works and whether it is required depends on other fields you use in your API call. See below for more detail.
                    ///
                    /// - Remark: Generated from `#/paths/chat.postEphemeral/POST/requestBody/json/text`.
                    public var text: Swift.String?
                    /// Provide another message's ts value to post this message in a thread. Avoid using a reply's ts value; use its parent's value instead. Ephemeral messages in threads are only
                    /// shown if there is already an active thread.
                    ///
                    /// - Remark: Generated from `#/paths/chat.postEphemeral/POST/requestBody/json/thread_ts`.
                    public var threadTs: Swift.String?
                    /// id of the user who will receive the ephemeral message. The user should be in the channel specified by the channel argument.
                    ///
                    /// - Remark: Generated from `#/paths/chat.postEphemeral/POST/requestBody/json/user`.
                    public var user: Swift.String
                    /// Set your bot's user name.
                    ///
                    /// - Remark: Generated from `#/paths/chat.postEphemeral/POST/requestBody/json/username`.
                    public var username: Swift.String?
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - asUser: (Legacy) Pass true to post the message as the authed user. Defaults to true if the chat:write:bot scope is not included. Otherwise, defaults to false.
                    ///   - attachments: A JSON-based array of structured attachments, presented as a URL-encoded string.
                    ///   - blocks: A JSON-based array of structured blocks, presented as a URL-encoded string.
                    ///   - channel: Channel, private group, or IM channel to send message to. Can be an encoded ID, or a name.
                    ///   - iconEmoji: Emoji to use as the icon for this message. Overrides icon_url.
                    ///   - iconUrl: URL to an image to use as the icon for this message.
                    ///   - linkNames: Find and link channel names and usernames.
                    ///   - markdownText: Accepts message text formatted in markdown. This argument should not be used in conjunction with blocks or text. Limit this field to 12,000 characters.
                    ///   - parse: Change how messages are treated. Defaults to none. See below.
                    ///   - text: How this field works and whether it is required depends on other fields you use in your API call. See below for more detail.
                    ///   - threadTs: Provide another message's ts value to post this message in a thread. Avoid using a reply's ts value; use its parent's value instead. Ephemeral messages in threads
                    /// are only shown if there is already an active thread.
                    ///   - user: id of the user who will receive the ephemeral message. The user should be in the channel specified by the channel argument.
                    ///   - username: Set your bot's user name.
                    public init(
                        asUser: Swift.Bool? = nil,
                        attachments: [SlackModels.Attachment]? = nil,
                        blocks: [SlackBlockKit.Block]? = nil,
                        channel: Swift.String,
                        iconEmoji: Swift.String? = nil,
                        iconUrl: Swift.String? = nil,
                        linkNames: Swift.Bool? = nil,
                        markdownText: Swift.String? = nil,
                        parse: Swift.String? = nil,
                        text: Swift.String? = nil,
                        threadTs: Swift.String? = nil,
                        user: Swift.String,
                        username: Swift.String? = nil,
                    ) {
                        self.asUser = asUser
                        self.attachments = attachments
                        self.blocks = blocks
                        self.channel = channel
                        self.iconEmoji = iconEmoji
                        self.iconUrl = iconUrl
                        self.linkNames = linkNames
                        self.markdownText = markdownText
                        self.parse = parse
                        self.text = text
                        self.threadTs = threadTs
                        self.user = user
                        self.username = username
                    }

                    public enum CodingKeys: String, CodingKey {
                        case asUser = "as_user"
                        case attachments
                        case blocks
                        case channel
                        case iconEmoji = "icon_emoji"
                        case iconUrl = "icon_url"
                        case linkNames = "link_names"
                        case markdownText = "markdown_text"
                        case parse
                        case text
                        case threadTs = "thread_ts"
                        case user
                        case username
                    }
                }

                /// - Remark: Generated from `#/paths/chat.postEphemeral/POST/requestBody/content/application\/json`.
                case json(Operations.ChatPostEphemeral.Input.Body.JsonPayload)
            }

            public var body: Operations.ChatPostEphemeral.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - headers:
            ///   - body:
            public init(
                headers: Operations.ChatPostEphemeral.Input.Headers = .init(),
                body: Operations.ChatPostEphemeral.Input.Body,
            ) {
                self.headers = headers
                self.body = body
            }
        }

        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/chat.postEphemeral/POST/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/chat.postEphemeral/POST/responses/200/content/application\/json`.
                    case json(Components.Schemas.ChatPostEphemeralResponse)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.ChatPostEphemeralResponse {
                        get throws {
                            switch self {
                            case let .json(body):
                                body
                            }
                        }
                    }
                }

                /// Received HTTP response body
                public var body: Operations.ChatPostEphemeral.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ChatPostEphemeral.Output.Ok.Body) {
                    self.body = body
                }
            }

            /// OK
            ///
            /// - Remark: Generated from `#/paths//chat.postEphemeral/post(chatPostEphemeral)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ChatPostEphemeral.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ChatPostEphemeral.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self,
                        )
                    }
                }
            }

            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }

        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }

            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    string
                case .json:
                    "application/json"
                }
            }

            public static var allCases: [Self] {
                [
                    .json,
                ]
            }
        }
    }

    public enum ChatPostMessage {
        public static let id: Swift.String = "chatPostMessage"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/chat.postMessage/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ChatPostMessage.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ChatPostMessage.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }

            public var headers: Operations.ChatPostMessage.Input.Headers
            /// - Remark: Generated from `#/paths/chat.postMessage/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/chat.postMessage/POST/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// (Legacy) Pass true to post the message as the authed user instead of as a bot. Defaults to false. Can only be used by classic apps. See legacy as_user parameter below.
                    ///
                    /// - Remark: Generated from `#/paths/chat.postMessage/POST/requestBody/json/as_user`.
                    public var asUser: Swift.Bool?
                    /// A JSON-based array of structured attachments, presented as a URL-encoded string.
                    ///
                    /// - Remark: Generated from `#/paths/chat.postMessage/POST/requestBody/json/attachments`.
                    public var attachments: [SlackModels.Attachment]?
                    /// A JSON-based array of structured blocks, presented as a URL-encoded string.
                    ///
                    /// - Remark: Generated from `#/paths/chat.postMessage/POST/requestBody/json/blocks`.
                    public var blocks: [SlackBlockKit.Block]?
                    /// An encoded ID or channel name that represents a channel, private group, or IM channel to send the message to. See below for more details.
                    ///
                    /// - Remark: Generated from `#/paths/chat.postMessage/POST/requestBody/json/channel`.
                    public var channel: Swift.String
                    /// This field represents the timestamp of the draft's last update at the time this API is called. If the current message is a draft, this field can be provided to ensure
                    /// synchronization with the server.
                    ///
                    /// - Remark: Generated from `#/paths/chat.postMessage/POST/requestBody/json/current_draft_last_updated_ts`.
                    public var currentDraftLastUpdatedTs: Swift.String?
                    /// Emoji to use as the icon for this message. Overrides icon_url.
                    ///
                    /// - Remark: Generated from `#/paths/chat.postMessage/POST/requestBody/json/icon_emoji`.
                    public var iconEmoji: Swift.String?
                    /// URL to an image to use as the icon for this message.
                    ///
                    /// - Remark: Generated from `#/paths/chat.postMessage/POST/requestBody/json/icon_url`.
                    public var iconUrl: Swift.String?
                    /// Find and link user groups. No longer supports linking individual users; use syntax shown in Mentioning Users instead.
                    ///
                    /// - Remark: Generated from `#/paths/chat.postMessage/POST/requestBody/json/link_names`.
                    public var linkNames: Swift.Bool?
                    /// Accepts message text formatted in markdown. This argument should not be used in conjunction with blocks or text. Limit this field to 12,000 characters.
                    ///
                    /// - Remark: Generated from `#/paths/chat.postMessage/POST/requestBody/json/markdown_text`.
                    public var markdownText: Swift.String?
                    /// JSON object with event_type and event_payload fields, presented as a URL-encoded string. You can also provide Work Object entity metadata using this parameter. Metadata you
                    /// post to Slack is accessible to any app or user who is a member of that workspace.
                    ///
                    /// - Remark: Generated from `#/paths/chat.postMessage/POST/requestBody/json/metadata`.
                    public var metadata: OpenAPIRuntime.OpenAPIObjectContainer?
                    /// Disable Slack markup parsing by setting to false. Enabled by default.
                    ///
                    /// - Remark: Generated from `#/paths/chat.postMessage/POST/requestBody/json/mrkdwn`.
                    public var mrkdwn: Swift.Bool?
                    /// Change how messages are treated. See below.
                    ///
                    /// - Remark: Generated from `#/paths/chat.postMessage/POST/requestBody/json/parse`.
                    public var parse: Swift.String?
                    /// Used in conjunction with thread_ts and indicates whether reply should be made visible to everyone in the channel or conversation. Defaults to false.
                    ///
                    /// - Remark: Generated from `#/paths/chat.postMessage/POST/requestBody/json/reply_broadcast`.
                    public var replyBroadcast: Swift.Bool?
                    /// How this field works and whether it is required depends on other fields you use in your API call. See below for more detail.
                    ///
                    /// - Remark: Generated from `#/paths/chat.postMessage/POST/requestBody/json/text`.
                    public var text: Swift.String?
                    /// Provide another message's ts value to make this message a reply. Avoid using a reply's ts value; use its parent instead.
                    ///
                    /// - Remark: Generated from `#/paths/chat.postMessage/POST/requestBody/json/thread_ts`.
                    public var threadTs: Swift.String?
                    /// Pass true to enable unfurling of primarily text-based content.
                    ///
                    /// - Remark: Generated from `#/paths/chat.postMessage/POST/requestBody/json/unfurl_links`.
                    public var unfurlLinks: Swift.Bool?
                    /// Pass false to disable unfurling of media content.
                    ///
                    /// - Remark: Generated from `#/paths/chat.postMessage/POST/requestBody/json/unfurl_media`.
                    public var unfurlMedia: Swift.Bool?
                    /// Set your bot's user name.
                    ///
                    /// - Remark: Generated from `#/paths/chat.postMessage/POST/requestBody/json/username`.
                    public var username: Swift.String?
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - asUser: (Legacy) Pass true to post the message as the authed user instead of as a bot. Defaults to false. Can only be used by classic apps. See legacy as_user parameter
                    /// below.
                    ///   - attachments: A JSON-based array of structured attachments, presented as a URL-encoded string.
                    ///   - blocks: A JSON-based array of structured blocks, presented as a URL-encoded string.
                    ///   - channel: An encoded ID or channel name that represents a channel, private group, or IM channel to send the message to. See below for more details.
                    ///   - currentDraftLastUpdatedTs: This field represents the timestamp of the draft's last update at the time this API is called. If the current message is a draft, this field can
                    /// be provided to ensure synchronization with the server.
                    ///   - iconEmoji: Emoji to use as the icon for this message. Overrides icon_url.
                    ///   - iconUrl: URL to an image to use as the icon for this message.
                    ///   - linkNames: Find and link user groups. No longer supports linking individual users; use syntax shown in Mentioning Users instead.
                    ///   - markdownText: Accepts message text formatted in markdown. This argument should not be used in conjunction with blocks or text. Limit this field to 12,000 characters.
                    ///   - metadata: JSON object with event_type and event_payload fields, presented as a URL-encoded string. You can also provide Work Object entity metadata using this parameter.
                    /// Metadata you post to Slack is accessible to any app or user who is a member of that workspace.
                    ///   - mrkdwn: Disable Slack markup parsing by setting to false. Enabled by default.
                    ///   - parse: Change how messages are treated. See below.
                    ///   - replyBroadcast: Used in conjunction with thread_ts and indicates whether reply should be made visible to everyone in the channel or conversation. Defaults to false.
                    ///   - text: How this field works and whether it is required depends on other fields you use in your API call. See below for more detail.
                    ///   - threadTs: Provide another message's ts value to make this message a reply. Avoid using a reply's ts value; use its parent instead.
                    ///   - unfurlLinks: Pass true to enable unfurling of primarily text-based content.
                    ///   - unfurlMedia: Pass false to disable unfurling of media content.
                    ///   - username: Set your bot's user name.
                    public init(
                        asUser: Swift.Bool? = nil,
                        attachments: [SlackModels.Attachment]? = nil,
                        blocks: [SlackBlockKit.Block]? = nil,
                        channel: Swift.String,
                        currentDraftLastUpdatedTs: Swift.String? = nil,
                        iconEmoji: Swift.String? = nil,
                        iconUrl: Swift.String? = nil,
                        linkNames: Swift.Bool? = nil,
                        markdownText: Swift.String? = nil,
                        metadata: OpenAPIRuntime.OpenAPIObjectContainer? = nil,
                        mrkdwn: Swift.Bool? = nil,
                        parse: Swift.String? = nil,
                        replyBroadcast: Swift.Bool? = nil,
                        text: Swift.String? = nil,
                        threadTs: Swift.String? = nil,
                        unfurlLinks: Swift.Bool? = nil,
                        unfurlMedia: Swift.Bool? = nil,
                        username: Swift.String? = nil,
                    ) {
                        self.asUser = asUser
                        self.attachments = attachments
                        self.blocks = blocks
                        self.channel = channel
                        self.currentDraftLastUpdatedTs = currentDraftLastUpdatedTs
                        self.iconEmoji = iconEmoji
                        self.iconUrl = iconUrl
                        self.linkNames = linkNames
                        self.markdownText = markdownText
                        self.metadata = metadata
                        self.mrkdwn = mrkdwn
                        self.parse = parse
                        self.replyBroadcast = replyBroadcast
                        self.text = text
                        self.threadTs = threadTs
                        self.unfurlLinks = unfurlLinks
                        self.unfurlMedia = unfurlMedia
                        self.username = username
                    }

                    public enum CodingKeys: String, CodingKey {
                        case asUser = "as_user"
                        case attachments
                        case blocks
                        case channel
                        case currentDraftLastUpdatedTs = "current_draft_last_updated_ts"
                        case iconEmoji = "icon_emoji"
                        case iconUrl = "icon_url"
                        case linkNames = "link_names"
                        case markdownText = "markdown_text"
                        case metadata
                        case mrkdwn
                        case parse
                        case replyBroadcast = "reply_broadcast"
                        case text
                        case threadTs = "thread_ts"
                        case unfurlLinks = "unfurl_links"
                        case unfurlMedia = "unfurl_media"
                        case username
                    }
                }

                /// - Remark: Generated from `#/paths/chat.postMessage/POST/requestBody/content/application\/json`.
                case json(Operations.ChatPostMessage.Input.Body.JsonPayload)
            }

            public var body: Operations.ChatPostMessage.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - headers:
            ///   - body:
            public init(
                headers: Operations.ChatPostMessage.Input.Headers = .init(),
                body: Operations.ChatPostMessage.Input.Body,
            ) {
                self.headers = headers
                self.body = body
            }
        }

        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/chat.postMessage/POST/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/chat.postMessage/POST/responses/200/content/application\/json`.
                    case json(Components.Schemas.ChatPostMessageResponse)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.ChatPostMessageResponse {
                        get throws {
                            switch self {
                            case let .json(body):
                                body
                            }
                        }
                    }
                }

                /// Received HTTP response body
                public var body: Operations.ChatPostMessage.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ChatPostMessage.Output.Ok.Body) {
                    self.body = body
                }
            }

            /// OK
            ///
            /// - Remark: Generated from `#/paths//chat.postMessage/post(chatPostMessage)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ChatPostMessage.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ChatPostMessage.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self,
                        )
                    }
                }
            }

            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }

        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }

            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    string
                case .json:
                    "application/json"
                }
            }

            public static var allCases: [Self] {
                [
                    .json,
                ]
            }
        }
    }

    public enum ChatScheduleMessage {
        public static let id: Swift.String = "chatScheduleMessage"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/chat.scheduleMessage/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ChatScheduleMessage.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ChatScheduleMessage.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }

            public var headers: Operations.ChatScheduleMessage.Input.Headers
            /// - Remark: Generated from `#/paths/chat.scheduleMessage/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/chat.scheduleMessage/POST/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// Set to true to post the message as the authed user, instead of as a bot. Defaults to false. Cannot be used by new Slack apps. See chat.postMessage.
                    ///
                    /// - Remark: Generated from `#/paths/chat.scheduleMessage/POST/requestBody/json/as_user`.
                    public var asUser: Swift.Bool?
                    /// A JSON-based array of structured attachments, presented as a URL-encoded string.
                    ///
                    /// - Remark: Generated from `#/paths/chat.scheduleMessage/POST/requestBody/json/attachments`.
                    public var attachments: [SlackModels.Attachment]?
                    /// A JSON-based array of structured blocks, presented as a URL-encoded string.
                    ///
                    /// - Remark: Generated from `#/paths/chat.scheduleMessage/POST/requestBody/json/blocks`.
                    public var blocks: [SlackBlockKit.Block]?
                    /// Channel, private group, or DM channel to send message to. Can be an encoded ID, or a name. See below for more details.
                    ///
                    /// - Remark: Generated from `#/paths/chat.scheduleMessage/POST/requestBody/json/channel`.
                    public var channel: Swift.String
                    /// Find and link user groups. No longer supports linking individual users; use syntax shown in Mentioning Users instead.
                    ///
                    /// - Remark: Generated from `#/paths/chat.scheduleMessage/POST/requestBody/json/link_names`.
                    public var linkNames: Swift.Bool?
                    /// Accepts message text formatted in markdown. This argument should not be used in conjunction with blocks or text. Limit this field to 12,000 characters.
                    ///
                    /// - Remark: Generated from `#/paths/chat.scheduleMessage/POST/requestBody/json/markdown_text`.
                    public var markdownText: Swift.String?
                    /// Change how messages are treated. See chat.postMessage.
                    ///
                    /// - Remark: Generated from `#/paths/chat.scheduleMessage/POST/requestBody/json/parse`.
                    public var parse: Swift.String?
                    /// Unix timestamp representing the future time the message should post to Slack.
                    ///
                    /// - Remark: Generated from `#/paths/chat.scheduleMessage/POST/requestBody/json/post_at`.
                    public var postAt: Swift.Int
                    /// Used in conjunction with thread_ts and indicates whether reply should be made visible to everyone in the channel or conversation. Defaults to false.
                    ///
                    /// - Remark: Generated from `#/paths/chat.scheduleMessage/POST/requestBody/json/reply_broadcast`.
                    public var replyBroadcast: Swift.Bool?
                    /// How this field works and whether it is required depends on other fields you use in your API call. See below for more detail.
                    ///
                    /// - Remark: Generated from `#/paths/chat.scheduleMessage/POST/requestBody/json/text`.
                    public var text: Swift.String?
                    /// Provide another message's ts value to make this message a reply. Avoid using a reply's ts value; use its parent instead.
                    ///
                    /// - Remark: Generated from `#/paths/chat.scheduleMessage/POST/requestBody/json/thread_ts`.
                    public var threadTs: Swift.String?
                    /// Pass true to enable unfurling of primarily text-based content.
                    ///
                    /// - Remark: Generated from `#/paths/chat.scheduleMessage/POST/requestBody/json/unfurl_links`.
                    public var unfurlLinks: Swift.Bool?
                    /// Pass false to disable unfurling of media content.
                    ///
                    /// - Remark: Generated from `#/paths/chat.scheduleMessage/POST/requestBody/json/unfurl_media`.
                    public var unfurlMedia: Swift.Bool?
                    /// JSON object with event_type and event_payload fields, presented as a URL-encoded string. Metadata you post to Slack is accessible to any app or user who is a member of that
                    /// workspace.
                    ///
                    /// - Remark: Generated from `#/paths/chat.scheduleMessage/POST/requestBody/json/metadata`.
                    public var metadata: OpenAPIRuntime.OpenAPIObjectContainer?
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - asUser: Set to true to post the message as the authed user, instead of as a bot. Defaults to false. Cannot be used by new Slack apps. See chat.postMessage.
                    ///   - attachments: A JSON-based array of structured attachments, presented as a URL-encoded string.
                    ///   - blocks: A JSON-based array of structured blocks, presented as a URL-encoded string.
                    ///   - channel: Channel, private group, or DM channel to send message to. Can be an encoded ID, or a name. See below for more details.
                    ///   - linkNames: Find and link user groups. No longer supports linking individual users; use syntax shown in Mentioning Users instead.
                    ///   - markdownText: Accepts message text formatted in markdown. This argument should not be used in conjunction with blocks or text. Limit this field to 12,000 characters.
                    ///   - parse: Change how messages are treated. See chat.postMessage.
                    ///   - postAt: Unix timestamp representing the future time the message should post to Slack.
                    ///   - replyBroadcast: Used in conjunction with thread_ts and indicates whether reply should be made visible to everyone in the channel or conversation. Defaults to false.
                    ///   - text: How this field works and whether it is required depends on other fields you use in your API call. See below for more detail.
                    ///   - threadTs: Provide another message's ts value to make this message a reply. Avoid using a reply's ts value; use its parent instead.
                    ///   - unfurlLinks: Pass true to enable unfurling of primarily text-based content.
                    ///   - unfurlMedia: Pass false to disable unfurling of media content.
                    ///   - metadata: JSON object with event_type and event_payload fields, presented as a URL-encoded string. Metadata you post to Slack is accessible to any app or user who is a
                    /// member of that workspace.
                    public init(
                        asUser: Swift.Bool? = nil,
                        attachments: [SlackModels.Attachment]? = nil,
                        blocks: [SlackBlockKit.Block]? = nil,
                        channel: Swift.String,
                        linkNames: Swift.Bool? = nil,
                        markdownText: Swift.String? = nil,
                        parse: Swift.String? = nil,
                        postAt: Swift.Int,
                        replyBroadcast: Swift.Bool? = nil,
                        text: Swift.String? = nil,
                        threadTs: Swift.String? = nil,
                        unfurlLinks: Swift.Bool? = nil,
                        unfurlMedia: Swift.Bool? = nil,
                        metadata: OpenAPIRuntime.OpenAPIObjectContainer? = nil,
                    ) {
                        self.asUser = asUser
                        self.attachments = attachments
                        self.blocks = blocks
                        self.channel = channel
                        self.linkNames = linkNames
                        self.markdownText = markdownText
                        self.parse = parse
                        self.postAt = postAt
                        self.replyBroadcast = replyBroadcast
                        self.text = text
                        self.threadTs = threadTs
                        self.unfurlLinks = unfurlLinks
                        self.unfurlMedia = unfurlMedia
                        self.metadata = metadata
                    }

                    public enum CodingKeys: String, CodingKey {
                        case asUser = "as_user"
                        case attachments
                        case blocks
                        case channel
                        case linkNames = "link_names"
                        case markdownText = "markdown_text"
                        case parse
                        case postAt = "post_at"
                        case replyBroadcast = "reply_broadcast"
                        case text
                        case threadTs = "thread_ts"
                        case unfurlLinks = "unfurl_links"
                        case unfurlMedia = "unfurl_media"
                        case metadata
                    }
                }

                /// - Remark: Generated from `#/paths/chat.scheduleMessage/POST/requestBody/content/application\/json`.
                case json(Operations.ChatScheduleMessage.Input.Body.JsonPayload)
            }

            public var body: Operations.ChatScheduleMessage.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - headers:
            ///   - body:
            public init(
                headers: Operations.ChatScheduleMessage.Input.Headers = .init(),
                body: Operations.ChatScheduleMessage.Input.Body,
            ) {
                self.headers = headers
                self.body = body
            }
        }

        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/chat.scheduleMessage/POST/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/chat.scheduleMessage/POST/responses/200/content/application\/json`.
                    case json(Components.Schemas.ChatScheduleMessageResponse)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.ChatScheduleMessageResponse {
                        get throws {
                            switch self {
                            case let .json(body):
                                body
                            }
                        }
                    }
                }

                /// Received HTTP response body
                public var body: Operations.ChatScheduleMessage.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ChatScheduleMessage.Output.Ok.Body) {
                    self.body = body
                }
            }

            /// OK
            ///
            /// - Remark: Generated from `#/paths//chat.scheduleMessage/post(chatScheduleMessage)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ChatScheduleMessage.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ChatScheduleMessage.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self,
                        )
                    }
                }
            }

            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }

        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }

            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    string
                case .json:
                    "application/json"
                }
            }

            public static var allCases: [Self] {
                [
                    .json,
                ]
            }
        }
    }

    public enum ChatUpdate {
        public static let id: Swift.String = "chatUpdate"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/chat.update/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ChatUpdate.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ChatUpdate.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }

            public var headers: Operations.ChatUpdate.Input.Headers
            /// - Remark: Generated from `#/paths/chat.update/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/chat.update/POST/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// Pass true to update the message as the authed user. Bot users in this context are considered authed users.
                    ///
                    /// - Remark: Generated from `#/paths/chat.update/POST/requestBody/json/as_user`.
                    public var asUser: Swift.Bool?
                    /// A JSON-based array of structured attachments, presented as a URL-encoded string.
                    ///
                    /// - Remark: Generated from `#/paths/chat.update/POST/requestBody/json/attachments`.
                    public var attachments: [SlackModels.Attachment]?
                    /// A JSON-based array of structured attachments, presented as a URL-encoded string.
                    ///
                    /// - Remark: Generated from `#/paths/chat.update/POST/requestBody/json/unfurled_attachments`.
                    public var unfurledAttachments: OpenAPIRuntime.OpenAPIObjectContainer?
                    /// A JSON-based array of structured blocks, presented as a URL-encoded string.
                    ///
                    /// - Remark: Generated from `#/paths/chat.update/POST/requestBody/json/blocks`.
                    public var blocks: [SlackBlockKit.Block]?
                    /// Accepts message text formatted in markdown. This argument should not be used in conjunction with blocks or text. Limit this field to 12,000 characters.
                    ///
                    /// - Remark: Generated from `#/paths/chat.update/POST/requestBody/json/markdown_text`.
                    public var markdownText: Swift.String?
                    /// JSON object with event_type and event_payload fields, presented as a URL-encoded string. If you don't include this field, the message's previous metadata will be retained. To
                    /// remove previous metadata, include an empty object for this field. Metadata you post to Slack is accessible to any app or user who is a member of that workspace.
                    ///
                    /// - Remark: Generated from `#/paths/chat.update/POST/requestBody/json/metadata`.
                    public var metadata: OpenAPIRuntime.OpenAPIObjectContainer?
                    /// Channel containing the message to be updated. For direct messages, ensure that this value is a DM ID (starts with D) instead of a User ID (starts with either U or W).
                    ///
                    /// - Remark: Generated from `#/paths/chat.update/POST/requestBody/json/channel`.
                    public var channel: Swift.String
                    /// Find and link channel names and usernames. Defaults to none. If you do not specify a value for this field, the original value set for the message will be overwritten with the
                    /// default, none.
                    ///
                    /// - Remark: Generated from `#/paths/chat.update/POST/requestBody/json/link_names`.
                    public var linkNames: Swift.Bool?
                    /// Change how messages are treated. Defaults to client, unlike chat.postMessage. Accepts either none or full. If you do not specify a value for this field, the original value set
                    /// for the message will be overwritten with the default, client.
                    ///
                    /// - Remark: Generated from `#/paths/chat.update/POST/requestBody/json/parse`.
                    public var parse: Swift.String?
                    /// How this field works and whether it is required depends on other fields you use in your API call. See below for more detail.
                    ///
                    /// - Remark: Generated from `#/paths/chat.update/POST/requestBody/json/text`.
                    public var text: Swift.String?
                    /// Timestamp of the message to be updated.
                    ///
                    /// - Remark: Generated from `#/paths/chat.update/POST/requestBody/json/ts`.
                    public var ts: Swift.String
                    /// Broadcast an existing thread reply to make it visible to everyone in the channel or conversation.
                    ///
                    /// - Remark: Generated from `#/paths/chat.update/POST/requestBody/json/reply_broadcast`.
                    public var replyBroadcast: Swift.Bool?
                    /// Array of new file ids that will be sent with this message.
                    ///
                    /// - Remark: Generated from `#/paths/chat.update/POST/requestBody/json/file_ids`.
                    public var fileIds: OpenAPIRuntime.OpenAPIArrayContainer?
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - asUser: Pass true to update the message as the authed user. Bot users in this context are considered authed users.
                    ///   - attachments: A JSON-based array of structured attachments, presented as a URL-encoded string.
                    ///   - unfurledAttachments: A JSON-based array of structured attachments, presented as a URL-encoded string.
                    ///   - blocks: A JSON-based array of structured blocks, presented as a URL-encoded string.
                    ///   - markdownText: Accepts message text formatted in markdown. This argument should not be used in conjunction with blocks or text. Limit this field to 12,000 characters.
                    ///   - metadata: JSON object with event_type and event_payload fields, presented as a URL-encoded string. If you don't include this field, the message's previous metadata will be
                    /// retained. To remove previous metadata, include an empty object for this field. Metadata you post to Slack is accessible to any app or user who is a member of that workspace.
                    ///   - channel: Channel containing the message to be updated. For direct messages, ensure that this value is a DM ID (starts with D) instead of a User ID (starts with either U or
                    /// W).
                    ///   - linkNames: Find and link channel names and usernames. Defaults to none. If you do not specify a value for this field, the original value set for the message will be
                    /// overwritten with the default, none.
                    ///   - parse: Change how messages are treated. Defaults to client, unlike chat.postMessage. Accepts either none or full. If you do not specify a value for this field, the original
                    /// value set for the message will be overwritten with the default, client.
                    ///   - text: How this field works and whether it is required depends on other fields you use in your API call. See below for more detail.
                    ///   - ts: Timestamp of the message to be updated.
                    ///   - replyBroadcast: Broadcast an existing thread reply to make it visible to everyone in the channel or conversation.
                    ///   - fileIds: Array of new file ids that will be sent with this message.
                    public init(
                        asUser: Swift.Bool? = nil,
                        attachments: [SlackModels.Attachment]? = nil,
                        unfurledAttachments: OpenAPIRuntime.OpenAPIObjectContainer? = nil,
                        blocks: [SlackBlockKit.Block]? = nil,
                        markdownText: Swift.String? = nil,
                        metadata: OpenAPIRuntime.OpenAPIObjectContainer? = nil,
                        channel: Swift.String,
                        linkNames: Swift.Bool? = nil,
                        parse: Swift.String? = nil,
                        text: Swift.String? = nil,
                        ts: Swift.String,
                        replyBroadcast: Swift.Bool? = nil,
                        fileIds: OpenAPIRuntime.OpenAPIArrayContainer? = nil,
                    ) {
                        self.asUser = asUser
                        self.attachments = attachments
                        self.unfurledAttachments = unfurledAttachments
                        self.blocks = blocks
                        self.markdownText = markdownText
                        self.metadata = metadata
                        self.channel = channel
                        self.linkNames = linkNames
                        self.parse = parse
                        self.text = text
                        self.ts = ts
                        self.replyBroadcast = replyBroadcast
                        self.fileIds = fileIds
                    }

                    public enum CodingKeys: String, CodingKey {
                        case asUser = "as_user"
                        case attachments
                        case unfurledAttachments = "unfurled_attachments"
                        case blocks
                        case markdownText = "markdown_text"
                        case metadata
                        case channel
                        case linkNames = "link_names"
                        case parse
                        case text
                        case ts
                        case replyBroadcast = "reply_broadcast"
                        case fileIds = "file_ids"
                    }
                }

                /// - Remark: Generated from `#/paths/chat.update/POST/requestBody/content/application\/json`.
                case json(Operations.ChatUpdate.Input.Body.JsonPayload)
            }

            public var body: Operations.ChatUpdate.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - headers:
            ///   - body:
            public init(
                headers: Operations.ChatUpdate.Input.Headers = .init(),
                body: Operations.ChatUpdate.Input.Body,
            ) {
                self.headers = headers
                self.body = body
            }
        }

        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/chat.update/POST/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/chat.update/POST/responses/200/content/application\/json`.
                    case json(Components.Schemas.ChatUpdateResponse)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.ChatUpdateResponse {
                        get throws {
                            switch self {
                            case let .json(body):
                                body
                            }
                        }
                    }
                }

                /// Received HTTP response body
                public var body: Operations.ChatUpdate.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ChatUpdate.Output.Ok.Body) {
                    self.body = body
                }
            }

            /// OK
            ///
            /// - Remark: Generated from `#/paths//chat.update/post(chatUpdate)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ChatUpdate.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ChatUpdate.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self,
                        )
                    }
                }
            }

            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }

        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }

            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    string
                case .json:
                    "application/json"
                }
            }

            public static var allCases: [Self] {
                [
                    .json,
                ]
            }
        }
    }

    public enum ChatAppendStream {
        public static let id: Swift.String = "chatAppendStream"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/chat.appendStream/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ChatAppendStream.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ChatAppendStream.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }

            public var headers: Operations.ChatAppendStream.Input.Headers
            /// - Remark: Generated from `#/paths/chat.appendStream/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/chat.appendStream/POST/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// An encoded ID that represents a channel, private group, or DM.
                    ///
                    /// - Remark: Generated from `#/paths/chat.appendStream/POST/requestBody/json/channel`.
                    public var channel: Swift.String
                    /// An array of streaming chunks. Chunks can be markdown text chunks, task update chunks, and plan update chunks.
                    ///
                    /// - Remark: Generated from `#/paths/chat.appendStream/POST/requestBody/json/chunks`.
                    public var chunks: OpenAPIRuntime.OpenAPIArrayContainer?
                    /// The timestamp of the streaming message.
                    ///
                    /// - Remark: Generated from `#/paths/chat.appendStream/POST/requestBody/json/ts`.
                    public var ts: Swift.String
                    /// Accepts message text formatted in markdown. Limit this field to 12,000 characters. This text is what will be appended to the message received so far.
                    ///
                    /// - Remark: Generated from `#/paths/chat.appendStream/POST/requestBody/json/markdown_text`.
                    public var markdownText: Swift.String
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - channel: An encoded ID that represents a channel, private group, or DM.
                    ///   - chunks: An array of streaming chunks. Chunks can be markdown text chunks, task update chunks, and plan update chunks.
                    ///   - ts: The timestamp of the streaming message.
                    ///   - markdownText: Accepts message text formatted in markdown. Limit this field to 12,000 characters. This text is what will be appended to the message received so far.
                    public init(
                        channel: Swift.String,
                        chunks: OpenAPIRuntime.OpenAPIArrayContainer? = nil,
                        ts: Swift.String,
                        markdownText: Swift.String,
                    ) {
                        self.channel = channel
                        self.chunks = chunks
                        self.ts = ts
                        self.markdownText = markdownText
                    }

                    public enum CodingKeys: String, CodingKey {
                        case channel
                        case chunks
                        case ts
                        case markdownText = "markdown_text"
                    }
                }

                /// - Remark: Generated from `#/paths/chat.appendStream/POST/requestBody/content/application\/json`.
                case json(Operations.ChatAppendStream.Input.Body.JsonPayload)
            }

            public var body: Operations.ChatAppendStream.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - headers:
            ///   - body:
            public init(
                headers: Operations.ChatAppendStream.Input.Headers = .init(),
                body: Operations.ChatAppendStream.Input.Body,
            ) {
                self.headers = headers
                self.body = body
            }
        }

        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/chat.appendStream/POST/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/chat.appendStream/POST/responses/200/content/application\/json`.
                    case json(Components.Schemas.ChatAppendStreamResponse)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.ChatAppendStreamResponse {
                        get throws {
                            switch self {
                            case let .json(body):
                                body
                            }
                        }
                    }
                }

                /// Received HTTP response body
                public var body: Operations.ChatAppendStream.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ChatAppendStream.Output.Ok.Body) {
                    self.body = body
                }
            }

            /// OK
            ///
            /// - Remark: Generated from `#/paths//chat.appendStream/post(chatAppendStream)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ChatAppendStream.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ChatAppendStream.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self,
                        )
                    }
                }
            }

            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }

        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }

            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    string
                case .json:
                    "application/json"
                }
            }

            public static var allCases: [Self] {
                [
                    .json,
                ]
            }
        }
    }

    public enum ChatDelete {
        public static let id: Swift.String = "chatDelete"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/chat.delete/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ChatDelete.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ChatDelete.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }

            public var headers: Operations.ChatDelete.Input.Headers
            /// - Remark: Generated from `#/paths/chat.delete/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/chat.delete/POST/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// (Legacy) Pass true to delete the message as the authed user with chat:write:user scope. Bot users in this context are considered authed users. See legacy as_user parameter
                    /// below.
                    ///
                    /// - Remark: Generated from `#/paths/chat.delete/POST/requestBody/json/as_user`.
                    public var asUser: Swift.Bool?
                    /// Channel containing the message to be deleted.
                    ///
                    /// - Remark: Generated from `#/paths/chat.delete/POST/requestBody/json/channel`.
                    public var channel: Swift.String
                    /// Timestamp of the message to be deleted.
                    ///
                    /// - Remark: Generated from `#/paths/chat.delete/POST/requestBody/json/ts`.
                    public var ts: Swift.String
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - asUser: (Legacy) Pass true to delete the message as the authed user with chat:write:user scope. Bot users in this context are considered authed users. See legacy as_user
                    /// parameter below.
                    ///   - channel: Channel containing the message to be deleted.
                    ///   - ts: Timestamp of the message to be deleted.
                    public init(
                        asUser: Swift.Bool? = nil,
                        channel: Swift.String,
                        ts: Swift.String,
                    ) {
                        self.asUser = asUser
                        self.channel = channel
                        self.ts = ts
                    }

                    public enum CodingKeys: String, CodingKey {
                        case asUser = "as_user"
                        case channel
                        case ts
                    }
                }

                /// - Remark: Generated from `#/paths/chat.delete/POST/requestBody/content/application\/json`.
                case json(Operations.ChatDelete.Input.Body.JsonPayload)
            }

            public var body: Operations.ChatDelete.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - headers:
            ///   - body:
            public init(
                headers: Operations.ChatDelete.Input.Headers = .init(),
                body: Operations.ChatDelete.Input.Body,
            ) {
                self.headers = headers
                self.body = body
            }
        }

        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/chat.delete/POST/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/chat.delete/POST/responses/200/content/application\/json`.
                    case json(Components.Schemas.ChatDeleteResponse)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.ChatDeleteResponse {
                        get throws {
                            switch self {
                            case let .json(body):
                                body
                            }
                        }
                    }
                }

                /// Received HTTP response body
                public var body: Operations.ChatDelete.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ChatDelete.Output.Ok.Body) {
                    self.body = body
                }
            }

            /// OK
            ///
            /// - Remark: Generated from `#/paths//chat.delete/post(chatDelete)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ChatDelete.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ChatDelete.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self,
                        )
                    }
                }
            }

            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }

        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }

            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    string
                case .json:
                    "application/json"
                }
            }

            public static var allCases: [Self] {
                [
                    .json,
                ]
            }
        }
    }

    public enum ChatDeleteScheduledMessage {
        public static let id: Swift.String = "chatDeleteScheduledMessage"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/chat.deleteScheduledMessage/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ChatDeleteScheduledMessage.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ChatDeleteScheduledMessage.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }

            public var headers: Operations.ChatDeleteScheduledMessage.Input.Headers
            /// - Remark: Generated from `#/paths/chat.deleteScheduledMessage/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/chat.deleteScheduledMessage/POST/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// Pass true to delete the message as the authed user with chat:write:user scope. Bot users in this context are considered authed users. If unused or false, the message will be
                    /// deleted with chat:write:bot scope.
                    ///
                    /// - Remark: Generated from `#/paths/chat.deleteScheduledMessage/POST/requestBody/json/as_user`.
                    public var asUser: Swift.Bool?
                    /// The channel the scheduled_message is posting to.
                    ///
                    /// - Remark: Generated from `#/paths/chat.deleteScheduledMessage/POST/requestBody/json/channel`.
                    public var channel: Swift.String
                    /// scheduled_message_id returned from call to chat.scheduleMessage.
                    ///
                    /// - Remark: Generated from `#/paths/chat.deleteScheduledMessage/POST/requestBody/json/scheduled_message_id`.
                    public var scheduledMessageId: Swift.String
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - asUser: Pass true to delete the message as the authed user with chat:write:user scope. Bot users in this context are considered authed users. If unused or false, the
                    /// message will be deleted with chat:write:bot scope.
                    ///   - channel: The channel the scheduled_message is posting to.
                    ///   - scheduledMessageId: scheduled_message_id returned from call to chat.scheduleMessage.
                    public init(
                        asUser: Swift.Bool? = nil,
                        channel: Swift.String,
                        scheduledMessageId: Swift.String,
                    ) {
                        self.asUser = asUser
                        self.channel = channel
                        self.scheduledMessageId = scheduledMessageId
                    }

                    public enum CodingKeys: String, CodingKey {
                        case asUser = "as_user"
                        case channel
                        case scheduledMessageId = "scheduled_message_id"
                    }
                }

                /// - Remark: Generated from `#/paths/chat.deleteScheduledMessage/POST/requestBody/content/application\/json`.
                case json(Operations.ChatDeleteScheduledMessage.Input.Body.JsonPayload)
            }

            public var body: Operations.ChatDeleteScheduledMessage.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - headers:
            ///   - body:
            public init(
                headers: Operations.ChatDeleteScheduledMessage.Input.Headers = .init(),
                body: Operations.ChatDeleteScheduledMessage.Input.Body,
            ) {
                self.headers = headers
                self.body = body
            }
        }

        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/chat.deleteScheduledMessage/POST/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/chat.deleteScheduledMessage/POST/responses/200/content/application\/json`.
                    case json(Components.Schemas.ChatDeleteScheduledMessageResponse)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.ChatDeleteScheduledMessageResponse {
                        get throws {
                            switch self {
                            case let .json(body):
                                body
                            }
                        }
                    }
                }

                /// Received HTTP response body
                public var body: Operations.ChatDeleteScheduledMessage.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ChatDeleteScheduledMessage.Output.Ok.Body) {
                    self.body = body
                }
            }

            /// OK
            ///
            /// - Remark: Generated from `#/paths//chat.deleteScheduledMessage/post(chatDeleteScheduledMessage)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ChatDeleteScheduledMessage.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ChatDeleteScheduledMessage.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self,
                        )
                    }
                }
            }

            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }

        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }

            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    string
                case .json:
                    "application/json"
                }
            }

            public static var allCases: [Self] {
                [
                    .json,
                ]
            }
        }
    }

    public enum ChatGetPermalink {
        public static let id: Swift.String = "chatGetPermalink"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/chat.getPermalink/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ChatGetPermalink.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ChatGetPermalink.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }

            public var headers: Operations.ChatGetPermalink.Input.Headers
            /// - Remark: Generated from `#/paths/chat.getPermalink/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/chat.getPermalink/POST/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// The ID of the conversation or channel containing the message.
                    ///
                    /// - Remark: Generated from `#/paths/chat.getPermalink/POST/requestBody/json/channel`.
                    public var channel: Swift.String
                    /// A message's ts value, uniquely identifying it within a channel.
                    ///
                    /// - Remark: Generated from `#/paths/chat.getPermalink/POST/requestBody/json/message_ts`.
                    public var messageTs: Swift.String
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - channel: The ID of the conversation or channel containing the message.
                    ///   - messageTs: A message's ts value, uniquely identifying it within a channel.
                    public init(
                        channel: Swift.String,
                        messageTs: Swift.String,
                    ) {
                        self.channel = channel
                        self.messageTs = messageTs
                    }

                    public enum CodingKeys: String, CodingKey {
                        case channel
                        case messageTs = "message_ts"
                    }
                }

                /// - Remark: Generated from `#/paths/chat.getPermalink/POST/requestBody/content/application\/json`.
                case json(Operations.ChatGetPermalink.Input.Body.JsonPayload)
            }

            public var body: Operations.ChatGetPermalink.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - headers:
            ///   - body:
            public init(
                headers: Operations.ChatGetPermalink.Input.Headers = .init(),
                body: Operations.ChatGetPermalink.Input.Body,
            ) {
                self.headers = headers
                self.body = body
            }
        }

        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/chat.getPermalink/POST/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/chat.getPermalink/POST/responses/200/content/application\/json`.
                    case json(Components.Schemas.ChatGetPermalinkResponse)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.ChatGetPermalinkResponse {
                        get throws {
                            switch self {
                            case let .json(body):
                                body
                            }
                        }
                    }
                }

                /// Received HTTP response body
                public var body: Operations.ChatGetPermalink.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ChatGetPermalink.Output.Ok.Body) {
                    self.body = body
                }
            }

            /// OK
            ///
            /// - Remark: Generated from `#/paths//chat.getPermalink/post(chatGetPermalink)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ChatGetPermalink.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ChatGetPermalink.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self,
                        )
                    }
                }
            }

            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }

        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }

            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    string
                case .json:
                    "application/json"
                }
            }

            public static var allCases: [Self] {
                [
                    .json,
                ]
            }
        }
    }

    public enum ChatMeMessage {
        public static let id: Swift.String = "chatMeMessage"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/chat.meMessage/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ChatMeMessage.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ChatMeMessage.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }

            public var headers: Operations.ChatMeMessage.Input.Headers
            /// - Remark: Generated from `#/paths/chat.meMessage/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/chat.meMessage/POST/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// Channel to send message to. Can be a public channel, private group or IM channel. Can be an encoded ID, or a name.
                    ///
                    /// - Remark: Generated from `#/paths/chat.meMessage/POST/requestBody/json/channel`.
                    public var channel: Swift.String
                    /// Text of the message to send.
                    ///
                    /// - Remark: Generated from `#/paths/chat.meMessage/POST/requestBody/json/text`.
                    public var text: Swift.String
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - channel: Channel to send message to. Can be a public channel, private group or IM channel. Can be an encoded ID, or a name.
                    ///   - text: Text of the message to send.
                    public init(
                        channel: Swift.String,
                        text: Swift.String,
                    ) {
                        self.channel = channel
                        self.text = text
                    }

                    public enum CodingKeys: String, CodingKey {
                        case channel
                        case text
                    }
                }

                /// - Remark: Generated from `#/paths/chat.meMessage/POST/requestBody/content/application\/json`.
                case json(Operations.ChatMeMessage.Input.Body.JsonPayload)
            }

            public var body: Operations.ChatMeMessage.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - headers:
            ///   - body:
            public init(
                headers: Operations.ChatMeMessage.Input.Headers = .init(),
                body: Operations.ChatMeMessage.Input.Body,
            ) {
                self.headers = headers
                self.body = body
            }
        }

        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/chat.meMessage/POST/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/chat.meMessage/POST/responses/200/content/application\/json`.
                    case json(Components.Schemas.ChatMeMessageResponse)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.ChatMeMessageResponse {
                        get throws {
                            switch self {
                            case let .json(body):
                                body
                            }
                        }
                    }
                }

                /// Received HTTP response body
                public var body: Operations.ChatMeMessage.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ChatMeMessage.Output.Ok.Body) {
                    self.body = body
                }
            }

            /// OK
            ///
            /// - Remark: Generated from `#/paths//chat.meMessage/post(chatMeMessage)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ChatMeMessage.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ChatMeMessage.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self,
                        )
                    }
                }
            }

            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }

        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }

            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    string
                case .json:
                    "application/json"
                }
            }

            public static var allCases: [Self] {
                [
                    .json,
                ]
            }
        }
    }

    public enum ChatScheduledMessagesList {
        public static let id: Swift.String = "chatScheduledMessagesList"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/chat.scheduledMessages.list/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ChatScheduledMessagesList.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ChatScheduledMessagesList.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }

            public var headers: Operations.ChatScheduledMessagesList.Input.Headers
            /// - Remark: Generated from `#/paths/chat.scheduledMessages.list/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/chat.scheduledMessages.list/POST/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// The channel of the scheduled messages.
                    ///
                    /// - Remark: Generated from `#/paths/chat.scheduledMessages.list/POST/requestBody/json/channel`.
                    public var channel: Swift.String?
                    /// For pagination purposes, this is the cursor value returned from a previous call to chat.scheduledmessages.list indicating where you want to start this call from.
                    ///
                    /// - Remark: Generated from `#/paths/chat.scheduledMessages.list/POST/requestBody/json/cursor`.
                    public var cursor: Swift.String?
                    /// A Unix timestamp of the latest value in the time range.
                    ///
                    /// - Remark: Generated from `#/paths/chat.scheduledMessages.list/POST/requestBody/json/latest`.
                    public var latest: Swift.String?
                    /// Maximum number of original entries to return.
                    ///
                    /// - Remark: Generated from `#/paths/chat.scheduledMessages.list/POST/requestBody/json/limit`.
                    public var limit: Swift.Int?
                    /// A Unix timestamp of the oldest value in the time range.
                    ///
                    /// - Remark: Generated from `#/paths/chat.scheduledMessages.list/POST/requestBody/json/oldest`.
                    public var oldest: Swift.String?
                    /// encoded team id to list channels in, required if org token is used.
                    ///
                    /// - Remark: Generated from `#/paths/chat.scheduledMessages.list/POST/requestBody/json/team_id`.
                    public var teamId: Swift.String?
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - channel: The channel of the scheduled messages.
                    ///   - cursor: For pagination purposes, this is the cursor value returned from a previous call to chat.scheduledmessages.list indicating where you want to start this call from.
                    ///   - latest: A Unix timestamp of the latest value in the time range.
                    ///   - limit: Maximum number of original entries to return.
                    ///   - oldest: A Unix timestamp of the oldest value in the time range.
                    ///   - teamId: encoded team id to list channels in, required if org token is used.
                    public init(
                        channel: Swift.String? = nil,
                        cursor: Swift.String? = nil,
                        latest: Swift.String? = nil,
                        limit: Swift.Int? = nil,
                        oldest: Swift.String? = nil,
                        teamId: Swift.String? = nil,
                    ) {
                        self.channel = channel
                        self.cursor = cursor
                        self.latest = latest
                        self.limit = limit
                        self.oldest = oldest
                        self.teamId = teamId
                    }

                    public enum CodingKeys: String, CodingKey {
                        case channel
                        case cursor
                        case latest
                        case limit
                        case oldest
                        case teamId = "team_id"
                    }
                }

                /// - Remark: Generated from `#/paths/chat.scheduledMessages.list/POST/requestBody/content/application\/json`.
                case json(Operations.ChatScheduledMessagesList.Input.Body.JsonPayload)
            }

            public var body: Operations.ChatScheduledMessagesList.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - headers:
            ///   - body:
            public init(
                headers: Operations.ChatScheduledMessagesList.Input.Headers = .init(),
                body: Operations.ChatScheduledMessagesList.Input.Body,
            ) {
                self.headers = headers
                self.body = body
            }
        }

        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/chat.scheduledMessages.list/POST/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/chat.scheduledMessages.list/POST/responses/200/content/application\/json`.
                    case json(Components.Schemas.ChatScheduledMessagesListResponse)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.ChatScheduledMessagesListResponse {
                        get throws {
                            switch self {
                            case let .json(body):
                                body
                            }
                        }
                    }
                }

                /// Received HTTP response body
                public var body: Operations.ChatScheduledMessagesList.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ChatScheduledMessagesList.Output.Ok.Body) {
                    self.body = body
                }
            }

            /// OK
            ///
            /// - Remark: Generated from `#/paths//chat.scheduledMessages.list/post(chatScheduledMessagesList)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ChatScheduledMessagesList.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ChatScheduledMessagesList.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self,
                        )
                    }
                }
            }

            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }

        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }

            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    string
                case .json:
                    "application/json"
                }
            }

            public static var allCases: [Self] {
                [
                    .json,
                ]
            }
        }
    }

    public enum ChatStartStream {
        public static let id: Swift.String = "chatStartStream"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/chat.startStream/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ChatStartStream.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ChatStartStream.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }

            public var headers: Operations.ChatStartStream.Input.Headers
            /// - Remark: Generated from `#/paths/chat.startStream/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/chat.startStream/POST/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// An encoded ID that represents a channel thread or DM.
                    ///
                    /// - Remark: Generated from `#/paths/chat.startStream/POST/requestBody/json/channel`.
                    public var channel: Swift.String
                    /// An array of streaming chunks. Chunks can be markdown text chunks, task update chunks, and plan update chunks.
                    ///
                    /// - Remark: Generated from `#/paths/chat.startStream/POST/requestBody/json/chunks`.
                    public var chunks: OpenAPIRuntime.OpenAPIArrayContainer?
                    /// Accepts message text formatted in markdown. Limit this field to 12,000 characters.
                    ///
                    /// - Remark: Generated from `#/paths/chat.startStream/POST/requestBody/json/markdown_text`.
                    public var markdownText: Swift.String?
                    /// Provide another message's ts value to reply to. Streamed messages should always be replies to a user request.
                    ///
                    /// - Remark: Generated from `#/paths/chat.startStream/POST/requestBody/json/thread_ts`.
                    public var threadTs: Swift.String
                    /// The encoded ID of the user to receive the streaming text. Required when streaming to channels.
                    ///
                    /// - Remark: Generated from `#/paths/chat.startStream/POST/requestBody/json/recipient_user_id`.
                    public var recipientUserId: Swift.String?
                    /// The encoded ID of the team the user receiving the streaming text belongs to. Required when streaming to channels.
                    ///
                    /// - Remark: Generated from `#/paths/chat.startStream/POST/requestBody/json/recipient_team_id`.
                    public var recipientTeamId: Swift.String?
                    /// Specifies how tasks are displayed in the message. A timeline displays individual tasks with text in sequential order, and plan displays all tasks together, with the first
                    /// tasks's placement determining the placement of the rest of the tasks.
                    ///
                    /// - Remark: Generated from `#/paths/chat.startStream/POST/requestBody/json/task_display_mode`.
                    public var taskDisplayMode: Swift.String?
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - channel: An encoded ID that represents a channel thread or DM.
                    ///   - chunks: An array of streaming chunks. Chunks can be markdown text chunks, task update chunks, and plan update chunks.
                    ///   - markdownText: Accepts message text formatted in markdown. Limit this field to 12,000 characters.
                    ///   - threadTs: Provide another message's ts value to reply to. Streamed messages should always be replies to a user request.
                    ///   - recipientUserId: The encoded ID of the user to receive the streaming text. Required when streaming to channels.
                    ///   - recipientTeamId: The encoded ID of the team the user receiving the streaming text belongs to. Required when streaming to channels.
                    ///   - taskDisplayMode: Specifies how tasks are displayed in the message. A timeline displays individual tasks with text in sequential order, and plan displays all tasks together,
                    /// with the first tasks's placement determining the placement of the rest of the tasks.
                    public init(
                        channel: Swift.String,
                        chunks: OpenAPIRuntime.OpenAPIArrayContainer? = nil,
                        markdownText: Swift.String? = nil,
                        threadTs: Swift.String,
                        recipientUserId: Swift.String? = nil,
                        recipientTeamId: Swift.String? = nil,
                        taskDisplayMode: Swift.String? = nil,
                    ) {
                        self.channel = channel
                        self.chunks = chunks
                        self.markdownText = markdownText
                        self.threadTs = threadTs
                        self.recipientUserId = recipientUserId
                        self.recipientTeamId = recipientTeamId
                        self.taskDisplayMode = taskDisplayMode
                    }

                    public enum CodingKeys: String, CodingKey {
                        case channel
                        case chunks
                        case markdownText = "markdown_text"
                        case threadTs = "thread_ts"
                        case recipientUserId = "recipient_user_id"
                        case recipientTeamId = "recipient_team_id"
                        case taskDisplayMode = "task_display_mode"
                    }
                }

                /// - Remark: Generated from `#/paths/chat.startStream/POST/requestBody/content/application\/json`.
                case json(Operations.ChatStartStream.Input.Body.JsonPayload)
            }

            public var body: Operations.ChatStartStream.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - headers:
            ///   - body:
            public init(
                headers: Operations.ChatStartStream.Input.Headers = .init(),
                body: Operations.ChatStartStream.Input.Body,
            ) {
                self.headers = headers
                self.body = body
            }
        }

        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/chat.startStream/POST/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/chat.startStream/POST/responses/200/content/application\/json`.
                    case json(Components.Schemas.ChatStartStreamResponse)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.ChatStartStreamResponse {
                        get throws {
                            switch self {
                            case let .json(body):
                                body
                            }
                        }
                    }
                }

                /// Received HTTP response body
                public var body: Operations.ChatStartStream.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ChatStartStream.Output.Ok.Body) {
                    self.body = body
                }
            }

            /// OK
            ///
            /// - Remark: Generated from `#/paths//chat.startStream/post(chatStartStream)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ChatStartStream.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ChatStartStream.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self,
                        )
                    }
                }
            }

            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }

        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }

            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    string
                case .json:
                    "application/json"
                }
            }

            public static var allCases: [Self] {
                [
                    .json,
                ]
            }
        }
    }

    public enum ChatStopStream {
        public static let id: Swift.String = "chatStopStream"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/chat.stopStream/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ChatStopStream.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ChatStopStream.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }

            public var headers: Operations.ChatStopStream.Input.Headers
            /// - Remark: Generated from `#/paths/chat.stopStream/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/chat.stopStream/POST/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// An encoded ID that represents a channel, private group, or DM.
                    ///
                    /// - Remark: Generated from `#/paths/chat.stopStream/POST/requestBody/json/channel`.
                    public var channel: Swift.String
                    /// An array of streaming chunks. Chunks can be markdown text chunks, task update chunks, and plan update chunks.
                    ///
                    /// - Remark: Generated from `#/paths/chat.stopStream/POST/requestBody/json/chunks`.
                    public var chunks: OpenAPIRuntime.OpenAPIArrayContainer?
                    /// The timestamp of the streaming message.
                    ///
                    /// - Remark: Generated from `#/paths/chat.stopStream/POST/requestBody/json/ts`.
                    public var ts: Swift.String
                    /// Accepts message text formatted in markdown. Limit this field to 12,000 characters.
                    ///
                    /// - Remark: Generated from `#/paths/chat.stopStream/POST/requestBody/json/markdown_text`.
                    public var markdownText: Swift.String?
                    /// A list of blocks that will be rendered at the bottom of the finalized message.
                    ///
                    /// - Remark: Generated from `#/paths/chat.stopStream/POST/requestBody/json/blocks`.
                    public var blocks: [SlackBlockKit.Block]?
                    /// JSON object with event_type and event_payload fields, presented as a URL-encoded string. Metadata you post to Slack is accessible to any app or user who is a member of that
                    /// workspace.
                    ///
                    /// - Remark: Generated from `#/paths/chat.stopStream/POST/requestBody/json/metadata`.
                    public var metadata: OpenAPIRuntime.OpenAPIObjectContainer?
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - channel: An encoded ID that represents a channel, private group, or DM.
                    ///   - chunks: An array of streaming chunks. Chunks can be markdown text chunks, task update chunks, and plan update chunks.
                    ///   - ts: The timestamp of the streaming message.
                    ///   - markdownText: Accepts message text formatted in markdown. Limit this field to 12,000 characters.
                    ///   - blocks: A list of blocks that will be rendered at the bottom of the finalized message.
                    ///   - metadata: JSON object with event_type and event_payload fields, presented as a URL-encoded string. Metadata you post to Slack is accessible to any app or user who is a
                    /// member of that workspace.
                    public init(
                        channel: Swift.String,
                        chunks: OpenAPIRuntime.OpenAPIArrayContainer? = nil,
                        ts: Swift.String,
                        markdownText: Swift.String? = nil,
                        blocks: [SlackBlockKit.Block]? = nil,
                        metadata: OpenAPIRuntime.OpenAPIObjectContainer? = nil,
                    ) {
                        self.channel = channel
                        self.chunks = chunks
                        self.ts = ts
                        self.markdownText = markdownText
                        self.blocks = blocks
                        self.metadata = metadata
                    }

                    public enum CodingKeys: String, CodingKey {
                        case channel
                        case chunks
                        case ts
                        case markdownText = "markdown_text"
                        case blocks
                        case metadata
                    }
                }

                /// - Remark: Generated from `#/paths/chat.stopStream/POST/requestBody/content/application\/json`.
                case json(Operations.ChatStopStream.Input.Body.JsonPayload)
            }

            public var body: Operations.ChatStopStream.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - headers:
            ///   - body:
            public init(
                headers: Operations.ChatStopStream.Input.Headers = .init(),
                body: Operations.ChatStopStream.Input.Body,
            ) {
                self.headers = headers
                self.body = body
            }
        }

        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/chat.stopStream/POST/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/chat.stopStream/POST/responses/200/content/application\/json`.
                    case json(Components.Schemas.ChatStopStreamResponse)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.ChatStopStreamResponse {
                        get throws {
                            switch self {
                            case let .json(body):
                                body
                            }
                        }
                    }
                }

                /// Received HTTP response body
                public var body: Operations.ChatStopStream.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ChatStopStream.Output.Ok.Body) {
                    self.body = body
                }
            }

            /// OK
            ///
            /// - Remark: Generated from `#/paths//chat.stopStream/post(chatStopStream)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ChatStopStream.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ChatStopStream.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self,
                        )
                    }
                }
            }

            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }

        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }

            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    string
                case .json:
                    "application/json"
                }
            }

            public static var allCases: [Self] {
                [
                    .json,
                ]
            }
        }
    }

    public enum ChatUnfurl {
        public static let id: Swift.String = "chatUnfurl"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/chat.unfurl/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ChatUnfurl.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ChatUnfurl.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }

            public var headers: Operations.ChatUnfurl.Input.Headers
            /// - Remark: Generated from `#/paths/chat.unfurl/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/chat.unfurl/POST/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// Channel ID of the message. Both channel and ts must be provided together, or unfurl_id and source must be provided together.
                    ///
                    /// - Remark: Generated from `#/paths/chat.unfurl/POST/requestBody/json/channel`.
                    public var channel: Swift.String?
                    /// Timestamp of the message to add unfurl behavior to.
                    ///
                    /// - Remark: Generated from `#/paths/chat.unfurl/POST/requestBody/json/ts`.
                    public var ts: Swift.String?
                    /// URL-encoded JSON map with keys set to URLs featured in the the message, pointing to their unfurl blocks or message attachments. Either unfurls or metadata must be provided.
                    ///
                    /// - Remark: Generated from `#/paths/chat.unfurl/POST/requestBody/json/unfurls`.
                    public var unfurls: OpenAPIRuntime.OpenAPIObjectContainer?
                    /// Provide a simply-formatted string to send as an ephemeral message to the user as invitation to authenticate further and enable full unfurling behavior. Provides two buttons,
                    /// Not now or Never ask me again.
                    ///
                    /// - Remark: Generated from `#/paths/chat.unfurl/POST/requestBody/json/user_auth_message`.
                    public var userAuthMessage: Swift.String?
                    /// Set to true or 1 to indicate the user must install your Slack app to trigger unfurls for this domain.
                    ///
                    /// - Remark: Generated from `#/paths/chat.unfurl/POST/requestBody/json/user_auth_required`.
                    public var userAuthRequired: Swift.Bool?
                    /// Send users to this custom URL where they will complete authentication in your app to fully trigger unfurling. Value should be properly URL-encoded.
                    ///
                    /// - Remark: Generated from `#/paths/chat.unfurl/POST/requestBody/json/user_auth_url`.
                    public var userAuthUrl: Swift.String?
                    /// Provide a JSON based array of structured blocks presented as URL-encoded string to send as an ephemeral message to the user as invitation to authenticate further and enable
                    /// full unfurling behavior.
                    ///
                    /// - Remark: Generated from `#/paths/chat.unfurl/POST/requestBody/json/user_auth_blocks`.
                    public var userAuthBlocks: OpenAPIRuntime.OpenAPIObjectContainer?
                    /// The ID of the link to unfurl. Both unfurl_id and source must be provided together, or channel and ts must be provided together.
                    ///
                    /// - Remark: Generated from `#/paths/chat.unfurl/POST/requestBody/json/unfurl_id`.
                    public var unfurlId: Swift.String?
                    /// The source of the link to unfurl. The source may either be composer, when the link is inside the message composer, or conversations_history, when the link has been posted to a
                    /// conversation.
                    ///
                    /// - Remark: Generated from `#/paths/chat.unfurl/POST/requestBody/json/source`.
                    public var source: Swift.String?
                    /// JSON object with an entities field providing an array of Work Object entities. Either unfurls or metadata must be provided.
                    ///
                    /// - Remark: Generated from `#/paths/chat.unfurl/POST/requestBody/json/metadata`.
                    public var metadata: OpenAPIRuntime.OpenAPIObjectContainer?
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - channel: Channel ID of the message. Both channel and ts must be provided together, or unfurl_id and source must be provided together.
                    ///   - ts: Timestamp of the message to add unfurl behavior to.
                    ///   - unfurls: URL-encoded JSON map with keys set to URLs featured in the the message, pointing to their unfurl blocks or message attachments. Either unfurls or metadata must be
                    /// provided.
                    ///   - userAuthMessage: Provide a simply-formatted string to send as an ephemeral message to the user as invitation to authenticate further and enable full unfurling behavior.
                    /// Provides two buttons, Not now or Never ask me again.
                    ///   - userAuthRequired: Set to true or 1 to indicate the user must install your Slack app to trigger unfurls for this domain.
                    ///   - userAuthUrl: Send users to this custom URL where they will complete authentication in your app to fully trigger unfurling. Value should be properly URL-encoded.
                    ///   - userAuthBlocks: Provide a JSON based array of structured blocks presented as URL-encoded string to send as an ephemeral message to the user as invitation to authenticate
                    /// further and enable full unfurling behavior.
                    ///   - unfurlId: The ID of the link to unfurl. Both unfurl_id and source must be provided together, or channel and ts must be provided together.
                    ///   - source: The source of the link to unfurl. The source may either be composer, when the link is inside the message composer, or conversations_history, when the link has been
                    /// posted to a conversation.
                    ///   - metadata: JSON object with an entities field providing an array of Work Object entities. Either unfurls or metadata must be provided.
                    public init(
                        channel: Swift.String? = nil,
                        ts: Swift.String? = nil,
                        unfurls: OpenAPIRuntime.OpenAPIObjectContainer? = nil,
                        userAuthMessage: Swift.String? = nil,
                        userAuthRequired: Swift.Bool? = nil,
                        userAuthUrl: Swift.String? = nil,
                        userAuthBlocks: OpenAPIRuntime.OpenAPIObjectContainer? = nil,
                        unfurlId: Swift.String? = nil,
                        source: Swift.String? = nil,
                        metadata: OpenAPIRuntime.OpenAPIObjectContainer? = nil,
                    ) {
                        self.channel = channel
                        self.ts = ts
                        self.unfurls = unfurls
                        self.userAuthMessage = userAuthMessage
                        self.userAuthRequired = userAuthRequired
                        self.userAuthUrl = userAuthUrl
                        self.userAuthBlocks = userAuthBlocks
                        self.unfurlId = unfurlId
                        self.source = source
                        self.metadata = metadata
                    }

                    public enum CodingKeys: String, CodingKey {
                        case channel
                        case ts
                        case unfurls
                        case userAuthMessage = "user_auth_message"
                        case userAuthRequired = "user_auth_required"
                        case userAuthUrl = "user_auth_url"
                        case userAuthBlocks = "user_auth_blocks"
                        case unfurlId = "unfurl_id"
                        case source
                        case metadata
                    }
                }

                /// - Remark: Generated from `#/paths/chat.unfurl/POST/requestBody/content/application\/json`.
                case json(Operations.ChatUnfurl.Input.Body.JsonPayload)
            }

            public var body: Operations.ChatUnfurl.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - headers:
            ///   - body:
            public init(
                headers: Operations.ChatUnfurl.Input.Headers = .init(),
                body: Operations.ChatUnfurl.Input.Body,
            ) {
                self.headers = headers
                self.body = body
            }
        }

        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/chat.unfurl/POST/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/chat.unfurl/POST/responses/200/content/application\/json`.
                    case json(Components.Schemas.ChatUnfurlResponse)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.ChatUnfurlResponse {
                        get throws {
                            switch self {
                            case let .json(body):
                                body
                            }
                        }
                    }
                }

                /// Received HTTP response body
                public var body: Operations.ChatUnfurl.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ChatUnfurl.Output.Ok.Body) {
                    self.body = body
                }
            }

            /// OK
            ///
            /// - Remark: Generated from `#/paths//chat.unfurl/post(chatUnfurl)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ChatUnfurl.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ChatUnfurl.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self,
                        )
                    }
                }
            }

            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }

        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }

            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    string
                case .json:
                    "application/json"
                }
            }

            public static var allCases: [Self] {
                [
                    .json,
                ]
            }
        }
    }
}
#endif
