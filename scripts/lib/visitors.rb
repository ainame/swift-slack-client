# in openapi.yaml, we don't have definitions section and instead it's components
class ReferenceFixer
  def walk(root)
    visit(root)
  end

  private

  def visit(data)
    case data
    when Array
      data.each { visit(_1) }
    when Hash
      if data.keys == ['$ref']
        data['$ref'].sub!('#/definitions/', '#/components/schemas/')
      else
        data.each_value { visit(_1) }
      end
    else
      data
    end
  end
end

# In common Slack response, `ok` always exists
class OptionalityFixer
  def walk(root)
    visit(root)
  end

  private

  def visit(data)
    case data
    when Array
      data.each { visit(_1) }
    when Hash
      if data.keys.include?('properties') && data.keys.include?('required') && data['properties'].keys.include?('ok') && !data['required'].include?('ok')
        data['required'].append('ok')
        data['required'].uniq!
      end

      # Additional properties should be allowed but don't need to be decoded
      data.delete('additionalProperties') if data.key?('additionalProperties')

      data.each_value { visit(_1) }
    else
      data
    end
  end
end

# Quicktype doesn't convert key's case
class SnakeCaseToCamelCaseConverter
  def walk(root)
    visit(root['definitions'])
  end

  private

  def visit(data)
    case data
    when Array
      data.each { visit(_1) }
    when Hash
      data.keys.each do |key|
        value = data[key]
        visit(value)
        next unless key.match?(/_/)

        camel_case_key = key.camelize
        data[camel_case_key] = value
        data.delete(key)
      end
    else
      data
    end
  end
end

# Force UpperCamelCase for acronyms; ie DND -> Dnd
# quicktype unintentionally choose capital case for acronyms
class AcronymsFixer
  def initialize(dictionary)
    @dictionary = dictionary
  end

  def walk(root)
    visit(root)
  end

  private

  def visit(data)
    case data
    when Array
      data.each { visit(_1) }
    when Hash
      data.keys.each do |key|
        value = data[key]
        visit(value)
        acronyms = @dictionary.keys.find { key =~ /#{_1}/ }
        next unless acronyms

        correct_case = @dictionary[acronyms]
        camel_case_key = key.gsub(acronyms) { correct_case }
        data[camel_case_key] = value
        data.delete(key)
      end
    else
      if data.is_a?(String) && acronyms = @dictionary.keys.find { data =~ /#{_1}/ }
        correct_case = @dictionary[acronyms]
        data.gsub!(acronyms) { correct_case }
      else
        data
      end
    end
  end
end

# Fix type generated by quicktype
class TypeFixer
  def walk(root)
    visit(root)
  end

  private

  def visit(data)
    case data
    when Array
      data.each { visit(_1) }
    when Hash
      data.keys.each do |key|
        case key
        when 'View', 'Block'
          # View and Block should be implemented by SlackBlockKit.
          # To remove relevant schemas used within View and Block but proceed with swift-openapi-generator,
          # empty View and Block and eventually remove generated code in different script.
          data[key] = {
            type: 'object',
            properties: {},
            additionalProperties: true
          }
        when 'AllowScFileUploads'
          data[key]['properties']['type'] = { type: 'string' }
        when 'Subteam'
          # Subteam is Usergroup
          data['Usergroup'] = data['Subteam']
        when 'Root'
          # Root should be called MessageRoot (for threads)
          data['MessageRoot'] = data['Root']
        when 'properties'
          data[key]&.each_key do |prop_name|
            # Match property name and corresponding type.
            # quicktype produces wrong types due to inconsistency in sample json in java-slack-sdk.
            case prop_name
            when /.*block$/i
              data[key][prop_name]['$ref'] = '#/components/schemas/Block'
            when /.*blocks$/i
              data[key][prop_name]['items']['$ref'] = '#/components/schemas/Block'
            when /^message$/
              data[key][prop_name]['$ref'] = '#/components/schemas/Message'
            when /.*Message$/
              data[key][prop_name]['$ref'] = '#/components/schemas/Message'
            when /^messages$/
              # when messages array's element is object and not string type
              if data[key][prop_name].dig('items', '$ref')
                data[key][prop_name]['items']['$ref'] = '#/components/schemas/Message'
              end
            when /^subteam$/
              # Subteam is actually Usergroup
              # https://docs.slack.dev/reference/events/subteam_updated
              if data[key][prop_name].key?('$ref')
                data[key][prop_name]['$ref'] = '#/components/schemas/Usergroup'
              end
            when /^root$/
              # Subteam is actually Usergroup
              # https://docs.slack.dev/reference/events/subteam_updated
              if data[key][prop_name]['$ref'] == '#/components/schemas/Root'
                data[key][prop_name]['$ref'] = '#/components/schemas/MessageRoot'
              end
            when /^workflowDraftConfiguration$/, /^workflowPublishedConfiguration$/
              # Workflow(Publish)Configuration and WorkflowDraftConfiguration is same
              if data[key][prop_name].key?('$ref')
                data[key][prop_name]['$ref'] = '#/components/schemas/WorkflowConfiguration'
              end
            end
          end
        end
      end
      data.each_value { visit(_1) }
    else
      data
    end
  end
end
