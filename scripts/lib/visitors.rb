# in openapi.yaml, we don't have definitions section and instead it's components
class ReferenceFixer
  def walk(root)
    visit(root)
  end

  private

  def visit(data)
    case data
    when Array
      data.each { visit(_1) }
    when Hash
      if data.keys == ['$ref']
        data['$ref'].sub!('#/definitions/', '#/components/schemas/')
      else
        data.each_value { visit(_1) }
      end
    else
      data
    end
  end
end

class InvalidKeysRemover
  def walk(root)
    visit(root)
  end

  private

  def visit(data)
    case data
    when Array
      data.each { visit(_1) }
    when Hash
      # AllowScFileUploads is an exception that doesn't need to have `type` but the source data has it...
      # https://github.com/slackapi/java-slack-sdk/blob/6f67d62486cd4b7a4d17e9a7de54db462a263e7a/slack-api-client/src/main/java/com/slack/api/methods/response/team/external_teams/TeamExternalTeamsListResponse.java#L84-L89
      data['AllowScFileUploads']['properties'].delete('type') if data.key?('AllowScFileUploads')

      data.each_value { visit(_1) }
    else
      data
    end
  end
end

# In common Slack response, `ok` always exists
class OptionalityFixer
  def walk(root)
    visit(root)
  end

  private

  def visit(data)
    case data
    when Array
      data.each { visit(_1) }
    when Hash
      if data.keys.include?('properties') && data.keys.include?('required')
        if data['properties'].keys.include?('ok')
          data['required'].append('ok')
          data['required'].uniq!
        end

        if data['properties']['type'] && data['properties']['type']['type'] == 'string'
          data['required'].append('type')
          data['required'].uniq!
        end
      end

      # Additional properties should be allowed but don't need to be decoded
      data.delete('additionalProperties') if data.key?('additionalProperties')

      data.each_value { visit(_1) }
    else
      data
    end
  end
end

# Quicktype doesn't convert key's case
class SnakeCaseToCamelCaseConverter
  def walk(root)
    visit(root['definitions'])
  end

  private

  def visit(data)
    case data
    when Array
      data.each { visit(_1) }
    when Hash
      data.keys.each do |key|
        value = data[key]
        visit(value)
        next unless key.match?(/_/)

        camel_case_key = key.camelize
        data[camel_case_key] = value
        data.delete(key)
      end
    else
      data
    end
  end
end

# Force UpperCamelCase for acronyms; ie DND -> Dnd
# quicktype unintentionally choose capital case for acronyms
class AcronymsFixer
  def initialize(dictionary)
    @dictionary = dictionary
  end

  def walk(root)
    visit(root)
  end

  private

  def visit(data)
    case data
    when Array
      data.each { visit(_1) }
    when Hash
      data.keys.each do |key|
        value = data[key]
        visit(value)
        acronyms = @dictionary.keys.find { key =~ /#{_1}/ }
        next unless acronyms

        correct_case = @dictionary[acronyms]
        camel_case_key = key.gsub(acronyms) { correct_case }
        data[camel_case_key] = value
        data.delete(key)
      end
    else
      if data.is_a?(String) && acronyms = @dictionary.keys.find { data =~ /#{_1}/ }
        correct_case = @dictionary[acronyms]
        data.gsub!(acronyms) { correct_case }
      else
        data
      end
    end
  end
end

# Fix type generated by quicktype
class TypeFixer
  def walk(root)
    visit(root)
  end

  private

  def visit(data)
    case data
    when Array
      data.each { visit(_1) }
    when Hash
      data.keys.each do |key|
        case key
        when 'View', 'Block'
          # View and Block should be implemented by SlackBlockKit.
          # To remove relevant schemas used within View and Block but proceed with swift-openapi-generator,
          # empty View and Block and eventually remove generated code in different script.
          data[key] = {
            type: 'object',
            properties: {},
            additionalProperties: true
          }
        when 'Subteam'
          # Subteam is Usergroup
          data['Usergroup'] = data['Subteam']
        when 'Root'
          # Root should be called MessageRoot (for threads)
          data['MessageRoot'] = data['Root']
        when 'properties'
          data[key]&.each_key do |prop_name|
            # Match property name and corresponding type.
            # quicktype produces wrong types due to inconsistency in sample json in java-slack-sdk.
            case prop_name
            when /.*block$/i
              data[key][prop_name]['$ref'] = '#/components/schemas/Block'
            when /.*blocks$/i
              data[key][prop_name]['items']['$ref'] = '#/components/schemas/Block'
            when /.*message$/i
              data[key][prop_name]['$ref'] = '#/components/schemas/Message'
            when /^messages$/
              # when messages array's element is object and not string type
              if data[key][prop_name].dig('items', '$ref')
                data[key][prop_name]['items']['$ref'] = '#/components/schemas/Message'
              end
            when /^subteam$/
              # Subteam is actually Usergroup
              # https://docs.slack.dev/reference/events/subteam_updated
              if data[key][prop_name].key?('$ref')
                data[key][prop_name]['$ref'] = '#/components/schemas/Usergroup'
              end
            when /^root$/
              # Subteam is actually Usergroup
              # https://docs.slack.dev/reference/events/subteam_updated
              if data[key][prop_name]['$ref'] == '#/components/schemas/Root'
                data[key][prop_name]['$ref'] = '#/components/schemas/MessageRoot'
              end
            when /^workflow_draft_configuration$/, /^workflow_published_configuration$/
              # Workflow(Publish)Configuration and WorkflowDraftConfiguration is same
              if data[key][prop_name].key?('$ref')
                data[key][prop_name]['$ref'] = '#/components/schemas/WorkflowConfiguration'
              end
            end
          end
        end
      end
      data.each_value { visit(_1) }
    else
      data
    end
  end
end

# Fix Item schema to add ts property as required for Slack event handling
class ItemTsRequiredFixer
  def walk(root)
    visit(root)
  end

  private

  def visit(data)
    case data
    when Array
      data.each { visit(_1) }
    when Hash
      # Target the Item schema specifically
      if data.key?('Item') && data['Item'].is_a?(Hash)
        item_schema = data['Item']
        if item_schema.key?('properties')
          # Add ts property if it doesn't exist
          unless item_schema['properties'].key?('ts')
            item_schema['properties']['ts'] = { 'type' => 'string' }
          end
          
          # Ensure required array exists
          item_schema['required'] ||= []
          # Add ts to required fields if not already present
          unless item_schema['required'].include?('ts')
            item_schema['required'] << 'ts'
          end
        end
      end

      data.each_value { visit(_1) }
    else
      data
    end
  end
end
